<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wasabi的个人博客</title>
  
  <subtitle>学入逆水行舟，不仅则退</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-29T12:36:21.729Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wasabi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maven技术</title>
    <link href="http://example.com/2021/04/29/Maven/"/>
    <id>http://example.com/2021/04/29/Maven/</id>
    <published>2021-04-29T08:09:41.000Z</published>
    <updated>2021-04-29T12:36:21.729Z</updated>
    
    <content type="html"><![CDATA[<p>自动化构建工具Maven</p><h2 id="一、Maven基础概念"><a href="#一、Maven基础概念" class="headerlink" title="一、Maven基础概念"></a>一、Maven基础概念</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-为什么用Maven"><a href="#1-为什么用Maven" class="headerlink" title="1 为什么用Maven"></a>1 为什么用Maven</h3><ol><li><p>庞大的项目，不适合用package来划分。最好一个模块对应一个工程，利于分工协作。</p></li><li><p>项目所需jar包必须手动导入WEB-INF/lib 目录下</p></li><li><p>jar包需要别人准备好，或官网下载</p></li><li><p>一个jar包依赖的其他jar包需要手动加到项目中</p></li><li><p>FileUpload插件-&gt;IO组件。commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar</p></li><li><p>如果所有jar之间的依赖关系都需要自己非常清楚的了解，极大的增加学习成本</p></li><li><p>Maven会自动将依赖的jar包导入进来。</p></li></ol><h3 id="2-Maven的概念"><a href="#2-Maven的概念" class="headerlink" title="2 Maven的概念"></a>2 Maven的概念</h3><ol><li><p>服务于Java平台的自动化构建</p></li><li><p>Make-&gt;Ant-&gt;Maven-&gt;Gradle</p></li><li><p>构建</p></li><li><p>概念：以”Java源文件”、”框架配置文件”、”JSP”,”HTML”、”图片”等资源为”原材料”，生产一个可运行的项目工程的过程。</p></li><li><p>编译：Java源文件-&gt;编译-&gt; Class字节码文件-&gt;JVM执行</p></li><li><p>部署：一个BS项目最终运行的不是动态Web工程本身，而是这个动态Web工程””编译的结果</p></li></ol><p>eclipse/navigator</p><p>例：生鸡-&gt;处理-&gt;熟鸡</p><p>动态Web工程-&gt;编译、部署-&gt;编译结果</p><p><em>开发过程中，所有的路径或配置文件中配置的类路径等都是以<strong>编译结果</strong>的目录结构为标准的</em></p><blockquote><p><em>当我们需要通过浏览器访问Java程序时就必须将包含Java程序的web工程编译的结果”拿”到服务器上的指定目录下，并启动服务器。”拿”的过程称为**</em>部署**。</p></blockquote><ol><li>搭建</li></ol><ul><li><p>build目录下存放的是字节码文件。</p></li><li><p>JRE、MySQL、tomcat等资源文件中存放的是，使用jar包的字节码文件。如果没有对应得资源文件，报错。</p></li><li><p>只是一组jar包的引用，并没有把jar包本身复制到工程中，所以并不是目录</p></li></ul><ol><li><p>构建过程的各个环节</p></li><li><p>清理：将以前编译得到的旧的class字节码删除，为下一次编译做准备</p></li><li><p>编译：将java源程序编译成class字节码文件</p></li><li><p>测试：自动测试，自动调用junit程序</p></li><li><p>报告：测试程序执行的结果</p></li><li><p>打包：动态Web工程打war包，Java工程打jar包</p></li><li><p>安装：Maven的特定概念——将打包得到的文件复制到”仓库”中的位置</p></li><li><p>部署：将动态Web工程生成的war包复制到servlet容器的指定目录下，使其可以运行</p></li><li><p>自动化构建</p></li><li><p>Maven的核心概念</p></li><li><p>约定的目录结构</p></li><li><p>POM</p></li><li><p>坐标</p></li><li><p>依赖</p></li><li><p>仓库</p></li><li><p>生命周期/插件/目标</p></li><li><p>继承</p></li><li><p>聚合</p></li></ol><h2 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h2><h3 id="1-安装Maven核心程序"><a href="#1-安装Maven核心程序" class="headerlink" title="1 安装Maven核心程序"></a>1 安装Maven核心程序</h3><ul><li><p>配置Maven相关环境变量</p></li><li><p>配置MAVEN_HOME或M2_HOME（玄学这个）</p></li><li><p>path（\bin）</p></li></ul><h3 id="2-创建Maven工程"><a href="#2-创建Maven工程" class="headerlink" title="2 创建Maven工程"></a>2 创建Maven工程</h3><ul><li><p>创建约定的目录结构</p></li><li><p>根目录：工程名</p></li><li><p>src目录：源码</p></li><li><p>pom.xml：Maven工程的核心配置文件</p></li><li><p>test目录：存放测试程序</p></li><li><p>java目录：存放Java源文件</p></li><li><p>resources目录：存放框架或其他工具的配置文件</p></li><li><p>遵守约定的目录结构 原因</p></li><li><p>Maven要负责我们这个项目的自动化构建</p></li><li><p>让框架知道我们自定的东西，两种方法</p></li><li><p>以配置的方式明确告诉框架</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;param-value&gt;classpath:spring-content.xml&lt;&#x2F;param-value&gt;</span><br></pre></td></tr></table></figure><ul><li>遵守框架内部已经存在的约定</li></ul><blockquote><p>log4j.properties</p><p>log4j.xml</p></blockquote><ul><li>JavaEE开发共识：约定 &gt; 配置 &gt; 编码 </li></ul><h3 id="3-常用maven命令"><a href="#3-常用maven命令" class="headerlink" title="3 常用maven命令"></a>3 常用maven命令</h3><ul><li><p>注意：执行与构建过程相关的maven命令，必须进入pom.xml所在目录</p></li><li><p>常用命令</p></li><li><p>mvn clean：清理</p></li><li><p>mvn compile：编译主程序</p></li><li><p>mvn test-compile：编译测试程序</p></li><li><p>mvc test：执行测试</p></li><li><p>mvn package:打包</p></li></ul><h3 id="4-关于联网的问题"><a href="#4-关于联网的问题" class="headerlink" title="4 关于联网的问题"></a>4 关于联网的问题</h3><ul><li><p>maven核心程序只定义了抽象的生命周期，具体的工作由插件完成.插件本身不包含在核心程序中。</p></li><li><p>执行maven命令需要插件时，核心程序先到本地仓库找</p></li><li><p>本地仓库的默认位置👇</p></li></ul><p>C:\Users[ 用户名 ].m2\repository</p><ul><li><p>本地没有，自动联网下载</p></li><li><p>修改maven仓库的位置可以让maven核心程序，到指定目录查找</p></li><li><p>Maven解压目录\conf\settings.xml</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepositor&gt;D:\path&lt;&#x2F;localRepositor&gt;</span><br></pre></td></tr></table></figure><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><ul><li>含义：Project Object Model项目对象模型</li><li>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切配置都在这个文件中。（同web.xml）</li></ul><p><a href="http://www.gylcode.cn/">www.gylcode.cn</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动化构建工具Maven&lt;/p&gt;
&lt;h2 id=&quot;一、Maven基础概念&quot;&gt;&lt;a href=&quot;#一、Maven基础概念&quot; class=&quot;headerlink&quot; title=&quot;一、Maven基础概念&quot;&gt;&lt;/a&gt;一、Maven基础概念&lt;/h2&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/2021/04/29/mysql/"/>
    <id>http://example.com/2021/04/29/mysql/</id>
    <published>2021-04-29T08:09:41.000Z</published>
    <updated>2021-04-29T12:51:59.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据与数据处理"><a href="#1-数据与数据处理" class="headerlink" title="1.数据与数据处理"></a>1.数据与数据处理</h2><h4 id="1-1数据"><a href="#1-1数据" class="headerlink" title="1.1数据"></a>1.1数据</h4><p>概念：存储在某种媒体上，能够识别的物理符号。</p><p>数据的概念包括两个方面：</p><p>（1）是描述事物特性的数据内容。</p><p>（2）是存在某种媒体上的数据形式。</p><p>数据的概念在数据的处理领域中已经大大的拓宽了，数据不仅包括数字，字母，文字和其他字符组成的文本形式的数据，而且还包括图形、图像、动画、影像、声音等多媒体数据。</p><h4 id="1-2数据处理"><a href="#1-2数据处理" class="headerlink" title="1.2数据处理"></a>1.2数据处理</h4><p>概念：是指 将数据装换成信息的过程。从数据处理角度而言，信息是一种被加工成特定形式的数据，这种数据形式对于数据的接收者来说是有意义的。</p><h3 id="2-计算机数据管理"><a href="#2-计算机数据管理" class="headerlink" title="2.计算机数据管理"></a>2.计算机数据管理</h3><h4 id="2-1概念："><a href="#2-1概念：" class="headerlink" title="2.1概念："></a>2.1概念：</h4><p><strong>数据处理中心问题是数据管理，数据管理是指对数据的组织、分类、编码、存储、检索和维护提供操作手段。</strong></p><h4 id="2-2数据管理发展阶段"><a href="#2-2数据管理发展阶段" class="headerlink" title="2.2数据管理发展阶段"></a>2.2数据管理发展阶段</h4><p><em>大致上包括三个阶段</em></p><p>①人工管理阶段–&gt;②文件系统阶段–&gt;<strong>③数据库系统阶段</strong></p><p>​                                  ②在文件系统阶段，由于出现了操作系统，使得程序和数据分开存放，有了数据文件和程序文件的区别，但是却不能分开处理，导致大量的数据冗余，从而产生了数据的不一致性。<strong>（能分开存放，但不能分开处理。）</strong></p><p>​                                                                    ③避免了数据冗余和不一致性的问题。为数据的建立，使用和维护而配置的软件称为数据库管理系统（DBMS）。数据库管理系统利用操作系统提供的输入输出控制和文件访问功能，因此他需要在操作系统的支持下运行</p><h3 id="3-数据库系统"><a href="#3-数据库系统" class="headerlink" title="3.数据库系统"></a>3.数据库系统</h3><p>（1）数据库（Database）是存储在计算机存储设备上的<em><strong>结构化的相关数据集合</strong></em>。他不仅包括描述事物的数据本身，而且还包括相关事物之间的联系。</p><p>（2）数据库管理系统</p><p>（3）数据库应用系统</p><p>（4）数据库管理员（DBA）指负责全面管理和实施数据库控制和维护的技术人员。</p><h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4.数据模型"></a>4.数据模型</h3><h4 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h4><p>（1）实体：客观存在并且可以相互区别的事物称为实体，实体即可以是实际的事物，也可以是抽象的事件。</p><p>（2）实体的属性：用来描述实体特性的内容称为实体的属性。</p><p>（3）实体集和实体型</p><p>相关属性的集合，构成了实体型，而某种属性相同或相近的实体型的集合称为实体集。</p><p>属性–&gt;实体型–&gt;实体集 （从小到大）</p><p>（4）实体之间联系的种类</p><p>​            ①一对一       ②一对多       ③多对多</p><h3 id="5-数据模型简介"><a href="#5-数据模型简介" class="headerlink" title="5.数据模型简介"></a>5.数据模型简介</h3><p>为了反映事物本身及事物之间的各种联系，数据库中的数据必须有一定的结构，这种结构用数据模型来表示。任何一个数据库管理系统都是基于某种数据模型的数据库管理系统所支持的数据模型分为三种：层次模型、网状模型和关系模型。</p><p>层次-特点：易于管理，速度慢。</p><p>网状-特点：分布式数据处理，通过网络串联，如果网络中某个节点出现问题，整体就不行。硬件设备要求高。数据存储灵活，硬件要求高，资金要求极高。</p><p>关系-特点：表结构，二维表。数据库主流模型。*****</p><h3 id="6-关系模型"><a href="#6-关系模型" class="headerlink" title="6.关系模型"></a>6.关系模型</h3><h4 id="6-1相关概念："><a href="#6-1相关概念：" class="headerlink" title="6.1相关概念："></a>6.1相关概念：</h4><p>（1）关系：一个关系就是一张二维表，每个关系都有一个关系名，一般称为表名。</p><p>对关系的描述称为关系模式，一个关系模式对应一个关系的结构，其结构为：</p><p><strong>关系明（属性名1，属性名2，…..，属性名n）</strong></p><p><em>例：学生（学号 姓名 性别 专业 出生日期 入学成绩）</em></p><p>（2）元组：在一个二维表中，水平方向的行称为元组</p><table><thead><tr><th>学号</th><th>姓名</th><th>性别</th><th>专业</th><th>成绩</th><th>生日</th><th>电话</th></tr></thead><tbody><tr><td>105</td><td>刘二</td><td>男</td><td></td><td></td><td></td><td></td></tr><tr><td>207</td><td>李四</td><td>女</td><td></td><td></td><td></td><td></td></tr><tr><td>109</td><td>张三</td><td>男</td><td></td><td></td><td></td><td></td></tr><tr><td>108</td><td>王五</td><td>男</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>（3）属性：二维表中垂直方向的列称为属性，每一列有一个属性名。</p><p>（4）域：属性的取值范围（必须具有合理性和合法性）</p><p>（5）（主）关键字：其值能唯一标识一个元组的属性或属性的组合称为关键字（也成为主关键字或主键）。</p><ol><li><p>实体完整性：记录唯一的特性（通过<strong>主键</strong>保证） </p></li><li><p>参照完整性</p><p>(1). 创建参照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 参照完整性</span><br><span class="line"># 当一个表插入记录的时候 受另一个表控制</span><br><span class="line">create table twarehouse(warehouseid varchar(3) primary key,city varchar(5),area float);</span><br><span class="line"></span><br><span class="line">create table tstaff(warehouseid varchar(8),staffid varchar(8) primary key,salary float,constraint aa foreign key (warehouseid) references twarehouse(warehouseid);</span><br><span class="line">#constraint(限制) 索引名 foreign key(普通索引) reference 表名(属性字段);</span><br><span class="line">                    </span><br><span class="line">-- 1. 插入时 子表受父表影响</span><br><span class="line">-- 2. 删除仓库 父表受子表影响</span><br><span class="line">-- 3. update 子表 父表都受约束</span><br><span class="line">#要想update 一个有 一个没有</span><br></pre></td></tr></table></figure><p>(2). 去掉参照，但是不删表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 去掉参照</span><br><span class="line">alter table tmpworkers drop foreign key aa;</span><br><span class="line">-- 后添加参照索引</span><br><span class="line">alter table workers add constraint ctr foreign key(warehouse_num) references warehouse(warehouse_num);</span><br><span class="line">-- 触发时序 --&gt; 增删改 时 才验证</span><br><span class="line"></span><br><span class="line">-- 建立删除普通索引</span><br><span class="line">alter table student add index(score);</span><br><span class="line">alter table student drop index score;</span><br><span class="line"></span><br><span class="line">-- 普通索引的名字 c</span><br><span class="line">alter table student add index c(score);</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">-- 主键 和 唯一索引 功能差不多 主键地位高 唯一索引次之</span><br><span class="line">-- 用名字建立的唯一索引  不能删除</span><br><span class="line">-- 有别名创建的 可以删除</span><br><span class="line">-- only mysql</span><br><span class="line">alter table student add unique uname(可以没有) index (name);</span><br><span class="line">alter table student drop unique uname index name;</span><br><span class="line"></span><br><span class="line">-- 建立索引的命令 跟alter table一样</span><br><span class="line">create index c on student (score);</span><br><span class="line">-- 删除索引的命令</span><br><span class="line">drop index c on student;</span><br></pre></td></tr></table></figure></li><li><p>域完整性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#域完整性</span><br><span class="line">-- check 和 default常连用</span><br><span class="line">check gender&#x3D;&#39;男&#39; or gender&#x3D;&#39;女&#39;default &#39;男&#39;;</span><br></pre></td></tr></table></figure><p>（6）外部关键字：如果表中的一个字段，不是本表的主关键字或候选关键字，而是另外一个表的主键或候选键，这样的属性（字段）就称为外关键字（外键），其主要作用就是为了保证表与表之间的某种联系。横 255</p><p>外键可以和主键相同</p><h4 id="6-2关系的特点："><a href="#6-2关系的特点：" class="headerlink" title="6.2关系的特点："></a>6.2关系的特点：</h4><p>（1）关系必须规范化。所谓规范化是指关系模型中的每一个关系模式都必须满足一定的要求。最基本的要求是每个属性必须是不可分割的数据单元。</p><p>（2）在同一个关系中，不能出现相同的属性名</p><p><em>例：姓名、name（合法）</em></p><p>（3）关系中不允许有完全相同的元组，即不允许有冗余</p><p>（4）在一个关系中，元组的顺序无关紧要。</p><p>（5）在一个关系中 列的顺序也无关紧要。</p><h3 id="7-设计原则"><a href="#7-设计原则" class="headerlink" title="7.设计原则"></a>7.设计原则</h3><h4 id="为了合理的组织数据，应遵从以下基本原则："><a href="#为了合理的组织数据，应遵从以下基本原则：" class="headerlink" title="为了合理的组织数据，应遵从以下基本原则："></a>为了合理的组织数据，应遵从以下基本原则：</h4><p>（1）关系数据的设计应遵从概念单一化“一事一地”原则。</p><p>（2）尽可能避免在表之间出现重复字段（外键除外）</p><p>（3）表中的字段尽可能是原始数据和基本元素，尽可能不使用可以计算字段。（工资和年龄）</p><p>（4）外部关键字保证有关联表之间的联系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table student(id varchar(8) primary key,name varchar(8),gender varchar(2),score float);</span><br><span class="line">desc student;</span><br><span class="line">drop table studet;#删除表</span><br><span class="line">create table student(id varchar(8) ,name varchar(8),gender varchar(2),score float primary key(id,name));&#x2F;*一个表一般一个主键  这是联合主键*&#x2F;</span><br><span class="line">&#x2F;*非空约束*&#x2F;</span><br><span class="line">create table student(id varchar(8) primary key,name varchar(8),gender varchar(2),age int(3) not null,score float);#年龄不能为空</span><br><span class="line">&#x2F;*默认值约束*&#x2F;</span><br><span class="line">create table student(id varchar(8) primary key,name varchar(8),gender varchar(2) default&#39;男&#39;,age int(3) not null,score float);&#x2F;&#x2F;默认值</span><br><span class="line">insert into student(id,name,age,score) values(&#39;1001001&#39;,&#39;li&#39;,&#39;19&#39;,&#39;95.5&#39;);</span><br><span class="line">&#x2F;*自动增值*&#x2F;</span><br><span class="line">create table student(id varchar(8) primary key auto increment,name varchar(8),gender varchar(2) default&#39;男&#39;,age int(3) not null,score float);</span><br><span class="line">insert into student(name,age,score) values(&#39;li&#39;,&#39;19&#39;,&#39;95.5&#39;);</span><br><span class="line">insert into student(name,age,score) values(&#39;wang&#39;,&#39;13&#39;,&#39;86.5&#39;);</span><br><span class="line">#id 自增1  如果删掉中间的一个  后面的id不改变</span><br><span class="line">#无法从新排列 自增的值</span><br><span class="line">delete from student where name&#x3D;&#39;wang&#39;;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure><p>能自动增值的只能是主键，是int类型。</p><p>**/  轻易不要改字段名 或 数据类型  /**</p><h2 id="2-数据类型和运算符"><a href="#2-数据类型和运算符" class="headerlink" title="2.数据类型和运算符"></a>2.数据类型和运算符</h2><p>MySQL支持多种数据类型，主要有数据类型，日期/时间型和字符串类型</p><h4 id="1-数值数据类型"><a href="#1-数值数据类型" class="headerlink" title="(1)数值数据类型"></a>(1)数值数据类型</h4><p>tinyint 最小整数类型 1B -128~127;</p><p>smallint 小整数 2B -32768~32767：</p><p>mediumint 中等大小的整数 3B -8388608~8388607;</p><p>int 普通整数 4B ;</p><p>bigint 最大整数 8B;</p><p>float 单精度浮点数4B</p><p>double 双精度浮点数8B</p><p>decimal（m，d）定点浮点数 M+2个字节</p><p><strong>一共m位，小数点后占d位。</strong></p><h4 id="2-日期与时间类型"><a href="#2-日期与时间类型" class="headerlink" title="(2)日期与时间类型"></a>(2)日期与时间类型</h4><p>YEAR 1901~2155 YYYY；</p><p>TIME HH:MM:SS;</p><p>DATE YYYY-MM-DD;</p><p><strong>DATETIME YYYY-MM-DD HH:MM:SS；</strong></p><p><strong>TIMESTAMP YYYY-MM-DD HH:MM:SS</strong>  –&gt;</p><p><em>1970</em>-01-01 00:00:00 UTC~2038-01-19 03:14:07UTC;</p><h4 id="3-文本字符串类型"><a href="#3-文本字符串类型" class="headerlink" title="(3)文本字符串类型"></a>(3)文本字符串类型</h4><p>CHAR(M) 固定长度的非二进制字符串</p><p>VARCHAR（M) 变长非二进制字符串 （计算及内部存储的时候 存储结构–是可以变长的）</p><p>TEXT L&lt;2^16</p><p>MEDIUMTEXT L&lt;2^24</p><p>LONGTEXT L&lt;2^32</p><h4 id="4-运算符"><a href="#4-运算符" class="headerlink" title="(4)运算符"></a>(4)运算符</h4><p>xor 异或 (^)不同为真 相同为假<br>$$<br>n &lt;&lt; m;  公式n*2^m;<br>$$</p><p>$$<br>n &gt;&gt; m;  公式：n/2^m;<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">select round（123.32452,2）#保留两位小数</span><br><span class="line">select sign(-85); #测试符号函数</span><br><span class="line">select pow (-8,1&#x2F;3);#错误 在语言中 负数不能开平方根</span><br><span class="line">select exp(2); #e的平方</span><br><span class="line">select log()；#以2.718为低 ()的对数</span><br><span class="line">select radians(180);#将角度 换成弧度</span><br><span class="line">select degreess(pi());# radians --&gt; angle</span><br><span class="line">select sin(pi()&#x2F;2);#traingle fun</span><br><span class="line">select char_length(&quot;good&quot;);#测试字符串长度</span><br><span class="line">#也可以不写char</span><br><span class="line">select concat_ws(&#39;,&#39;,&#39;good&#39;,&#39;afternoon&#39;,&#39;ohyes&#39;);</span><br><span class="line">#字符以什么隔开</span><br><span class="line">select insert(&#39;asdfasdfas&#39;,3,3,&#39;2fadgyjera&#39;);</span><br><span class="line">#from 3 get 3 change&#39;XXXX&#39;,不是从0开始 。</span><br><span class="line">select insert(&#39;asdfasdfas&#39;,3,0,&#39;XXXX&#39;);</span><br><span class="line">#insert</span><br><span class="line">select lower(&#39;&#39;);</span><br><span class="line">#lower case;lcase</span><br><span class="line">select upper(&#39;&#39;);</span><br><span class="line">#ucase</span><br><span class="line">select left(&quot;fadjfasdgtr&quot;,3);</span><br><span class="line">#from left get 3--&gt;fad</span><br><span class="line">select substring(&#39;fasdfadsgfae&#39;,4,3);</span><br><span class="line">#from...  get...</span><br><span class="line">select concat(ltrim(&#39; hello &#39;),&#39;jessica&#39;);</span><br><span class="line">#remove left space</span><br><span class="line">#rtrim right space</span><br><span class="line">#trim l+r;</span><br><span class="line">select concat(&#39;good&#39;,repeat(&#39;&#39;,20),&#39;morning&#39;);</span><br><span class="line">#重复产生字符</span><br><span class="line">select replace(&#39;abcdefghijklmnopqrst&#39;,&#39;def&#39;,&#39;wwwww&#39;);</span><br><span class="line">#all def to wwwww;</span><br><span class="line">select strcmp(a1,a2);</span><br><span class="line">#a1&gt;a2 1 a1&lt;a2 -1 a1&#x3D;a2 0</span><br><span class="line">select locate (&#39;a1&#39;,&#39;a2&#39;);</span><br><span class="line">#from a2 find a1&#39;s location;</span><br><span class="line">select position(&#39;def&#39; in &#39;abcdefhkjl&#39;);</span><br><span class="line">#the same result as locate;</span><br><span class="line">select reverse(&#39;abc&#39;);</span><br><span class="line">select now();</span><br><span class="line">select current_date();</span><br><span class="line">select current_time();</span><br><span class="line">select month(now());</span><br><span class="line">select localtime();</span><br><span class="line">select sysdate();</span><br><span class="line">select monthname(now());#october</span><br><span class="line">select dayofweek(now());#sunday monday tuesday</span><br><span class="line">select weekday(now());#weekday index; monday:0</span><br><span class="line">select schema();&#x3D;&#x3D;select database();</span><br><span class="line">&#x2F;* 加密 解密 *&#x2F;  ##非常重要</span><br><span class="line">select * from test_table where md5(&#39;orange&#39;)&#x3D;pwd;</span><br><span class="line">#MD5</span><br><span class="line">insert into test_table values(&#39;1001001&#39;,&#39;li&#39;,password(&#39;appleopen&#39;));</span><br><span class="line">#password</span><br><span class="line">show create table test;</span><br><span class="line">#charset;</span><br><span class="line">①</span><br><span class="line">create table test (id varchar(8),name varchar(8),pwd varchar(50)) engine&#x3D;InnoDB default charset&#x3D;latin1;</span><br><span class="line">②</span><br><span class="line">insert into test values(&#39;1001001&#39;,&#39;wang&#39;,encode(&#39;apple&#39;,&#39;my&#39;));</span><br><span class="line">#apple is password my is passkey</span><br></pre></td></tr></table></figure><h2 id="3-SQL语言"><a href="#3-SQL语言" class="headerlink" title="3.SQL语言"></a>3.SQL语言</h2><p>1.SQL是Structured Query Language（结构化查询语言）</p><p>可以说查询是语言的重要组成部分，但不是全部。SQL还包括数据定义，数据操纵，数据控制功能等部分。SQL已经成为关系数据库的标准数据语言，所以现在所有的关系数据库管理系统都支持SQL。</p><h4 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">--  between ... and ...第一个值小于等于第二个值</span><br><span class="line">select * from staff_table where salary between 1230 and 1250;</span><br><span class="line"></span><br><span class="line">-- 包含公司字符的供应商名户信息</span><br><span class="line"># mysql 方言</span><br><span class="line">select </span><br><span class="line">* </span><br><span class="line">from </span><br><span class="line">supplier </span><br><span class="line">where </span><br><span class="line">position(&#39;公司&#39; in suppliername)&gt;0;</span><br><span class="line"></span><br><span class="line">-- 通行写法</span><br><span class="line">select</span><br><span class="line">*</span><br><span class="line">from </span><br><span class="line">supplier</span><br><span class="line">where </span><br><span class="line">suppliername </span><br><span class="line">like #just like (num cant)</span><br><span class="line">&#39;%公司%&#39;; </span><br><span class="line"># % --&gt; 任意的   通配符;# _ --&gt; 下划线通配符 只能是一个</span><br><span class="line"></span><br><span class="line">-- 计算查询 *******重點</span><br><span class="line"># 1. count計數（就count 可*）</span><br><span class="line">select</span><br><span class="line">count(*)</span><br><span class="line">from</span><br><span class="line">warehouse</span><br><span class="line">where</span><br><span class="line">warehouse_num</span><br><span class="line">in(</span><br><span class="line">select </span><br><span class="line">    staff_id</span><br><span class="line">    from </span><br><span class="line">    staff_table </span><br><span class="line">    where </span><br><span class="line">    salary&gt;1230</span><br><span class="line">);</span><br><span class="line">#sum avg max min</span><br><span class="line"></span><br><span class="line">-- 分組計算</span><br><span class="line">#分組搭配計算更方便</span><br><span class="line">select </span><br><span class="line">warehouse_num,sum(salary) </span><br><span class="line">#先按倉庫號分組，然後求和</span><br><span class="line">from </span><br><span class="line">staff_table </span><br><span class="line">group by </span><br><span class="line">warehouse_num;</span><br><span class="line">#分組</span><br><span class="line"># where 是分組前完成的 --&gt; 分組 --&gt; cal</span><br><span class="line">#寫的時候 也在group by之前</span><br><span class="line">select warehouse_num,count(*) as 人數 ,sum(salary) from staff_table group by warehouse_num having count(*)&gt;&#x3D;2;</span><br><span class="line">#having：對分組以後 進行第二次篩選 不能獨立使用 只能與group by 連用</span><br><span class="line">-- 利用空值繼續查詢</span><br><span class="line">select * from purchase where supply is null;</span><br><span class="line">-- 正则表达式</span><br><span class="line">select * from purchase where supply regexp&#39;^OR7&#39;;</span><br><span class="line">#以OR7开头的</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>查询功能</p><p>检索出工资多于1230元的职工号</p><p>检索出哪些仓库有工资多于1210元的职工     </p><p>给处在仓库WH1或 WH2中工作，并且工资少于1250元的职工号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">*找出工资多于1230元的职工号和他们所在的城市，</span><br><span class="line">*哪些城市至少有一个仓库的职工的工资为1250元？</span><br><span class="line">*&#x2F;</span><br><span class="line">select </span><br><span class="line">    city </span><br><span class="line">from   </span><br><span class="line">    warehouse </span><br><span class="line">where</span><br><span class="line">    warehouse_num </span><br><span class="line">in(</span><br><span class="line">    select</span><br><span class="line">        warehouse_num</span><br><span class="line">    from</span><br><span class="line">        staff_table</span><br><span class="line">    where</span><br><span class="line">        salary&#x3D;1250</span><br><span class="line">);</span><br><span class="line">#嵌套查询 mysql可多次嵌套</span><br><span class="line">#连接查询有可能出现重复值，嵌套查询几乎不存在此话题。</span><br></pre></td></tr></table></figure><h4 id="2-别名自连接查询-与-内外层互相关嵌套"><a href="#2-别名自连接查询-与-内外层互相关嵌套" class="headerlink" title="2.别名自连接查询 与 内外层互相关嵌套"></a>2.别名自连接查询 与 内外层互相关嵌套</h4><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>别名自连接查询</p><p>在某些要求中 别名并不是必须的，但是在关系的自连接操作中，别名就是必不可少的了。SQL不仅可以对多个关系进行连接操作，也可以将同一个关系与其自身进行连接，在这种连接就称为自连接。在可以进行这种自连接的操作的关系上，实际存在着一种特殊的递归关系，即关系中的一些元组，根据<strong>出自同一个值域的两个不同属性</strong>，可以与另外一些<strong>元组</strong>有一种对应关系。1:n. module</p><p>内外层互相关嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from warehouse where warehouse_num in(select warehouse_num from Staff_table where salary&#x3D;1250);</span><br><span class="line">外查询用里查询的结果  不一定用的上里循环的结果</span><br></pre></td></tr></table></figure><p>列出每个职工经手的具有最高金额的订购单信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from purchase p </span><br><span class="line">where </span><br><span class="line">total&#x3D;(</span><br><span class="line">select max(total)</span><br><span class="line">from purchase k where p.staff_id&#x3D;k.staff_id)</span><br></pre></td></tr></table></figure><p>子查询先查，都是同时指向第一个</p><p>检索出工资低于本仓库平均工资的职工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from staff_table w</span><br><span class="line">where salary &lt;</span><br><span class="line">(select avg(salary) from staff_table k where k.staff_id&#x3D;w.staff_id);</span><br></pre></td></tr></table></figure><h4 id="3-超连接查询"><a href="#3-超连接查询" class="headerlink" title="3.超连接查询"></a>3.超连接查询</h4><h5 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h5><p>SQL标准中支持两个比较特殊的连接运算符，他们与原来我们所了解的等值连接和自然连接不同。原来的连接是只有满足连接条件，相应的结果才会出现在结果表中：而这两个特殊的连接运算符是，首先保证一个表中满足条件的元组都在结果表中，然后将满足连接条件的元组与另一个表的元组进行连接，不满足条件的则应将来自另一个表的属性的值设为空值。一般标准中将这个称谓左连接“* =”，将这个称为右连接“= *”，在实现这种连接操作的数据库管理系统中，其表现形式有所差异。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 等值连接</span><br><span class="line">select * from warehouse inner join staff_table on warehouse.warehouse_num&#x3D;staff_table.warehouse_num;</span><br><span class="line">-- 去掉重复属性的等值连接 叫自然连接</span><br><span class="line">select warehouse.*,staff_id,salary from warehouse inner join staff_table on warehouse.warehouse_num&#x3D;staff_table.warehouse_num;</span><br><span class="line">-- 左连接</span><br><span class="line">#以左面的表为基准    inner 可以省略</span><br><span class="line">select * from warehouse left inner join staff_table on warehouse.warehouse_num&#x3D;staff_table.warehouse_num;</span><br><span class="line"></span><br><span class="line">-- 右连接</span><br><span class="line">#以右面的表为基准</span><br><span class="line">select * from warehouse right inner join staff_table on warehouse.warehouse_num&#x3D;staff_table.warehouse_num;</span><br><span class="line"></span><br><span class="line">-- 完全连接</span><br><span class="line">#能连 连不上的互相给空值</span><br><span class="line">##mysql没有完全连接  SQL标准有。</span><br></pre></td></tr></table></figure><h4 id="4-集合并运算"><a href="#4-集合并运算" class="headerlink" title="4.集合并运算"></a>4.集合并运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from warehouse where city&#x3D;&#39;北京&#39; union select * from warehouse where city&#x3D;&#39;上海&#39;;</span><br><span class="line">#前后有一个不同 都不行。</span><br></pre></td></tr></table></figure><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h2><h4 id="4-1-概念："><a href="#4-1-概念：" class="headerlink" title="4.1 概念："></a>4.1 概念：</h4><p>用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行。表越大，查询数据所花费的时间越多。如果表中查询的列有一个索引，MySQL就能快速到达某个位置去搜寻数据，而不必查看所有数据。</p><p>索引是对数据表中的一列或多列的值进行排序的一种结构，使用索引可提高数据库中特定数据的查询速度。它是一种单独的存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针，所有的MySQL列类型都可以被索引。</p><h4 id="4-2优点"><a href="#4-2优点" class="headerlink" title="4.2优点"></a>4.2优点</h4><h5 id="1-唯一性"><a href="#1-唯一性" class="headerlink" title="(1)唯一性"></a>(1)唯一性</h5><p>通过创建唯一索引可以保证数据每一行数据的唯一性。</p><p>(候选键的问题)</p><h5 id="2-速度快"><a href="#2-速度快" class="headerlink" title="(2)速度快"></a>(2)速度快</h5><p>可以大大加快数据的查询速度，这也是创建索引的主要原因。</p><h5 id="3-加速表之间的连接"><a href="#3-加速表之间的连接" class="headerlink" title="(3)加速表之间的连接"></a>(3)加速表之间的连接</h5><p>在实现数据的参照完整性方面可以加速表和表之间的连接。</p><h5 id="4-分组或排序子句也可提速"><a href="#4-分组或排序子句也可提速" class="headerlink" title="(4)分组或排序子句也可提速"></a>(4)分组或排序子句也可提速</h5><p>在使用分组和排序子句进行数据查询时，也可以提高数据的处理速度。</p><h4 id="4-3不利因素"><a href="#4-3不利因素" class="headerlink" title="4.3不利因素"></a>4.3不利因素</h4><h5 id="1-维护费劲"><a href="#1-维护费劲" class="headerlink" title="(1)维护费劲"></a>(1)维护费劲</h5><p>创建索引和维护索引要耗时间，并且随着数据量的增大所耗费的事件就会增加。</p><h5 id="2-占用磁盘空间"><a href="#2-占用磁盘空间" class="headerlink" title="(2)占用磁盘空间"></a>(2)占用磁盘空间</h5><p>索引本身也会占用一定的磁盘空间，作为原数据表的辅助文件存在，即原数据表增加后，索引也会随之增大。</p><h5 id="3-增删改"><a href="#3-增删改" class="headerlink" title="(3)增删改"></a>(3)增删改</h5><p>当对元数据进行增加、删除和修改操作时，索引也要进行维护，这样就降低了数据的维护速度。</p><h4 id="4-4索引的设计原则"><a href="#4-4索引的设计原则" class="headerlink" title="4.4索引的设计原则"></a>4.4索引的设计原则</h4><h5 id="1-索引不是越多越好"><a href="#1-索引不是越多越好" class="headerlink" title="(1)索引不是越多越好"></a>(1)索引不是越多越好</h5><h5 id="2-避免对经常更新的表进行过多的索引"><a href="#2-避免对经常更新的表进行过多的索引" class="headerlink" title="(2)避免对经常更新的表进行过多的索引"></a>(2)避免对经常更新的表进行过多的索引</h5><h5 id="3-数据量小的表，尽量不要建索引"><a href="#3-数据量小的表，尽量不要建索引" class="headerlink" title="(3)数据量小的表，尽量不要建索引"></a>(3)数据量小的表，尽量不要建索引</h5><h5 id="4-尽可能不要再值域较小的字段上创建索引"><a href="#4-尽可能不要再值域较小的字段上创建索引" class="headerlink" title="(4)尽可能不要再值域较小的字段上创建索引"></a>(4)尽可能不要再值域较小的字段上创建索引</h5><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 建索引 birthday</span><br><span class="line">create table user(id varchar(8) primary key,name varchar(8),gender varchar(3),birthday date,phone varchar(11),memo varchar(100),index(birthday));</span><br><span class="line">-- 查看索引</span><br><span class="line">possible:key birthday # 可选用索引</span><br><span class="line">key:birthday # 当前使用的索引</span><br><span class="line">key_len # 索引的长度</span><br><span class="line"></span><br><span class="line">-- 看索引列表</span><br><span class="line">explain select * from ttable where index&#x3D;1990\G;</span><br><span class="line">-- 辅键</span><br><span class="line">create table user2(id varchar(8) primary key,name varchar(8),gender varchar(3)unique key(name));</span><br><span class="line">insert into user2 values(&#39;1001&#39;,&#39;li&#39;,&#39;男&#39;),(&#39;102&#39;,&#39;吗&#39;,&#39;女&#39;);</span><br><span class="line">insert into user2 values(&#39;1003&#39;,&#39;li&#39;,&#39;男&#39;),(&#39;102&#39;,&#39;吗&#39;,&#39;女&#39;);</span><br><span class="line">&#x2F;*ERROR 1062 (23000): Duplicate entry &#39;li&#39; for key &#39;name&#39;*&#x2F;</span><br><span class="line"></span><br><span class="line">-- 索引起别名</span><br><span class="line">create table user2(id int primary key ,name varchar(8),gender varchar(3),unique key tmpKey (name));</span><br><span class="line"></span><br><span class="line">-- 组合索引 是一个索引 根据两个值建立的 </span><br><span class="line"># --&gt;字符串拼接</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-数据库的编程"><a href="#5-数据库的编程" class="headerlink" title="5.数据库的编程"></a>5.数据库的编程</h2><p>==难点==</p><p>存储过程和函数</p><p><em>/不带值 存储过程 带值的存储函数/</em></p><h3 id="5-1-概念："><a href="#5-1-概念：" class="headerlink" title="5.1 概念："></a>5.1 概念：</h3><p>简单说 存储过程就是一条或多条SQL语句的集合，可视为批处理文件，但其作用不仅限于批处理。</p><h3 id="5-2-创建存储过程和函数"><a href="#5-2-创建存储过程和函数" class="headerlink" title="5.2 创建存储过程和函数"></a>5.2 创建存储过程和函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter &#x2F;&#x2F; -- 将&#x2F;&#x2F; 设为结束符号</span><br><span class="line">create procedure myp() -- 创建存储过程的命令</span><br><span class="line">begin -- 开始 类&#123;</span><br><span class="line">select * from worker;-- 操作1</span><br><span class="line">select 8+5;-- 操作2</span><br><span class="line">end&#x2F;&#x2F;-- 结束 类&#125;</span><br><span class="line"></span><br><span class="line">delimiter ; -- 将分号再转为结束符号</span><br><span class="line"></span><br><span class="line">call myp();-- 调用myp()函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DELIMITER @@</span><br><span class="line">DROP PROCEDURE testP @@</span><br><span class="line">CREATE PROCEDURE training.testP</span><br><span class="line">(out mysum double) -- 往外送值</span><br><span class="line">begin </span><br><span class="line">    select sum(total) into mysum from purchase;</span><br><span class="line">    把sum(total)的值 送进mysum</span><br><span class="line">end @@ </span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">call testP1(5,6,@k);</span><br><span class="line">select @k;</span><br><span class="line">-- 函数 ———————————————————————————————————————</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">DROP function testf1 &#x2F;&#x2F;</span><br><span class="line">CREATE function training.testf1(x int ,y int )</span><br><span class="line">return int </span><br><span class="line">begin</span><br><span class="line">return (select x+y);</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br><span class="line">______________________________________________</span><br><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure testP2()</span><br><span class="line">begin</span><br><span class="line">--     declare x int default 0;-- 定义一个变量 初始值是0</span><br><span class="line">--     declare y varchar(10) default &#39;&#39;;</span><br><span class="line">--     declare z int;</span><br><span class="line">--     select x;</span><br><span class="line">--     set x&#x3D;15,y&#x3D;35;</span><br><span class="line">-- 对变量赋值 是set 命令 </span><br><span class="line">-- 输出 是select</span><br><span class="line">    declare tmpSum double default 0;</span><br><span class="line">-- 给变量赋值</span><br><span class="line">select sum(total) into tmpSum from purchase;</span><br><span class="line">select tmpSum;</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br><span class="line">-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure testP2()</span><br><span class="line">(in x double,in y double,out result double)</span><br><span class="line">begin -- **********************</span><br><span class="line">declare tmax double;</span><br><span class="line">if x&gt;y then</span><br><span class="line">    set tmax&#x3D;x;</span><br><span class="line">else</span><br><span class="line">    set tmax&#x3D;y;</span><br><span class="line">end if;</span><br><span class="line">select tmx into result; -- 跟表有关</span><br><span class="line">-- set result &#x3D; tmax;  存储过程 和 函数里</span><br><span class="line">end &#x2F;&#x2F;-- *******************</span><br><span class="line">delimiter ;</span><br><span class="line">-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">drop procedure testp1 &#x2F;&#x2F;</span><br><span class="line">create procedure mysql.testp1</span><br><span class="line">(in x double)</span><br><span class="line">begin </span><br><span class="line">case </span><br><span class="line">    when x&gt;&#x3D;90 and x&lt;&#x3D;100 then select &#39;A&#39;;</span><br><span class="line">    when x&gt;&#x3D;80 and x&lt;90 then select &#39;B&#39;;</span><br><span class="line">    else select &#39;C&#39;;</span><br><span class="line">end case;</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br><span class="line">-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure testp2()</span><br><span class="line">begin </span><br><span class="line">declare i int default 1;</span><br><span class="line">declare s int default 0;</span><br><span class="line">apple:loop    -- apple is a label , like goto</span><br><span class="line">    set s&#x3D;s+i;</span><br><span class="line">    set i&#x3D;i+1;</span><br><span class="line">    if i&gt;100 then</span><br><span class="line">        leave apple;</span><br><span class="line">    end if;</span><br><span class="line">end loop apple;</span><br><span class="line">select s;</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br><span class="line">-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure testp2()</span><br><span class="line">begin </span><br><span class="line">declare i int default 1;</span><br><span class="line">declare s int default 0;</span><br><span class="line">while i&lt;&#x3D;100 do</span><br><span class="line">    set s&#x3D;s+i;</span><br><span class="line">    set i&#x3D;i+1;</span><br><span class="line">end while;</span><br><span class="line">select s;</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h3 id="5-3光标的使用"><a href="#5-3光标的使用" class="headerlink" title="==5.3光标的使用=="></a>==5.3光标的使用==</h3><p>查询语句可能返回多条记录，如果数据量非常大 ，需要在存储过程和存储函数中使用光标来逐条读取查询结果集中的记录。应用程序可以根据需要滚动或浏览其中的数据。</p><p>==<strong>注意： 光标在使用前必须声明</strong>==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">DROP PROCEDURE testP3 @@</span><br><span class="line">CREATE PROCEDURE training.testP3()</span><br><span class="line">begin</span><br><span class="line">declare tmpArea float default 0;</span><br><span class="line">declare tmpCity varchar(10) default &#39;&#39;;</span><br><span class="line">declare results varchar(150) default &#39;&#39;;</span><br><span class="line">declare curl cursor for select city,area from warehouse;</span><br><span class="line">declare continue handler for sqlstate &#39;02000&#39; set tmpCity &#x3D; null;</span><br><span class="line">open curl;</span><br><span class="line">fetch curl into tmpCity,tmpArea;</span><br><span class="line">while (tmpCity is not null) do</span><br><span class="line">    set results&#x3D;concat(results,&#39;,&#39;,tmpCity,&#39;#&#39;,tmpArea);</span><br><span class="line">    fetch curl into tmpCity,tmpArea;</span><br><span class="line">end while;</span><br><span class="line">close curl;</span><br><span class="line">select results;</span><br><span class="line">end @@ </span><br><span class="line">DELIMITER ; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-视图"><a href="#6-视图" class="headerlink" title="6.视图"></a>6.视图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 虚拟表，但无结构。  --&gt; 映射</span><br><span class="line">-- 对视图的任何改变 都是对原表的改变</span><br><span class="line">create view tview1 as select * from warehouse;</span><br></pre></td></tr></table></figure><h2 id="7-用户管理"><a href="#7-用户管理" class="headerlink" title="7.用户管理"></a>7.用户管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 向创建用户 --&gt; 对用户分配权限 --&gt; </span><br></pre></td></tr></table></figure><p>MySQL数据库是一个多用户数据库，具有功能强大的访问控制能力，可以为不同用户指定允许的权限。MySQL用户分为 普通用户和root用户。root用户就是超级管理员，拥有所有权限，包括创建用户 、删除用户、和修改用户密码等管理权限。普通用户，只拥有被授予的各种权限。</p><p>与权限有关的重要数据表  –&gt; MySQL中的user表、db表、priv表、columns_priv、proce_priv。</p><p>（update硬改表，需要查看上列文件 是否有问题）</p><p>performance_schema.hosts</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="2020-10-27"><a href="#2020-10-27" class="headerlink" title="2020.10.27"></a>2020.10.27</h2><p>1.检索在北京供应商的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">    supply_name</span><br><span class="line">from</span><br><span class="line">    supply_table</span><br><span class="line">where</span><br><span class="line">    address&#x3D;&#39;北京&#39;;</span><br></pre></td></tr></table></figure><p>2.检索出向供应商S3发过订单的职工的职工号和仓库号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">warehouse_num,staff_id </span><br><span class="line">#所求最终结果</span><br><span class="line">from </span><br><span class="line">staff_table </span><br><span class="line">#来自职工表</span><br><span class="line">where </span><br><span class="line">staff_id </span><br><span class="line">#什么样的职工号--&gt;</span><br><span class="line">in(</span><br><span class="line">    select staff_id </span><br><span class="line">    from purchase </span><br><span class="line">    where supply&#x3D;&#39;S3&#39;</span><br><span class="line">);</span><br><span class="line">#求 职工号和仓库号 并向S3下过订单 </span><br><span class="line">#1.有三个表 </span><br><span class="line">#①职工表--&gt; 职工号和仓库号 </span><br><span class="line">#②订购单表--&gt;供应商号和职工号</span><br><span class="line">#③供应商表--&gt;供应商号</span><br></pre></td></tr></table></figure><p>3.检索出和职工E1、E3 都有联系的北京供应商信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select * from supply_id where address&#39;北京&#39; and supply_id in(select supply from purchase where staff_id&#x3D;&#39;E3&#39;) and supply_id in(select supply from purchase where staff_id&#x3D;&#39;E1&#39;);</span><br><span class="line"></span><br><span class="line">--  复盘 sqlserver 2008</span><br><span class="line">select *</span><br><span class="line">from gys</span><br><span class="line">where gys_addr&#x3D;&#39;北京&#39; and gys_id in</span><br><span class="line">(</span><br><span class="line">select dd_gys</span><br><span class="line">from dd </span><br><span class="line">where dd_zg&#x3D;&#39;E1&#39; or dd_zg &#x3D;&#39;E3&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>4.检索出向S4供应商发出订单的仓库所在的城市</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select city</span><br><span class="line">from warehouse </span><br><span class="line">where warehouse_num</span><br><span class="line">in(</span><br><span class="line">    select warehouse_num</span><br><span class="line">    from staff_table</span><br><span class="line">    where staff_id</span><br><span class="line">    </span><br><span class="line">    in( select staff_id </span><br><span class="line">        from purchase</span><br><span class="line">        where supply&#x3D;&#39;S4&#39;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>5.检索出由工资多于1230元的职工向北京的供应商发出的订购单号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select order_id</span><br><span class="line">from purchase</span><br><span class="line">where supply in(select supply_id from supply_table where address&#x3D;&#39;北京&#39;) and staff_id in(select staff_id from staff_table where salary&gt;&#39;1230&#39;);</span><br></pre></td></tr></table></figure><p>== distinct 需进行第二次排查 时效性较低  ==</p><p>2020/10/28-作业：</p><p>1.插入一个新的供应商元组（S9，智通公司，沈阳）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tsupply_table values(&#39;S9&#39;,&#39;智通公司&#39;,&#39;沈阳&#39;);</span><br></pre></td></tr></table></figure><p>2.删除当前没有任何订单的供应商</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete </span><br><span class="line">from tsupply_table</span><br><span class="line">where supply_id </span><br><span class="line">not in (select supply from purchase where supply_id is not null);</span><br><span class="line">-- 要去除空值</span><br></pre></td></tr></table></figure><p>3.删除由在上海仓库工作的职工发出的所有订购单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">delete </span><br><span class="line">from purchase</span><br><span class="line">where order_id</span><br><span class="line">-- select order_id</span><br><span class="line">-- from purchase</span><br><span class="line">-- where staff_id </span><br><span class="line">in(</span><br><span class="line">    select staff_id </span><br><span class="line">    from staff_table</span><br><span class="line">    where warehouse_num</span><br><span class="line">    in(</span><br><span class="line">        select warehouse_num</span><br><span class="line">        from warehouse</span><br><span class="line">        where city&#x3D;&#39;上海&#39;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4.北京的所有仓库增加一百平米</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update warehouse set area&#x3D;area+100</span><br><span class="line">where city&#x3D;&#39;北京&#39;;</span><br></pre></td></tr></table></figure><p>5.给低于所有职工平均工资的职工提高5%的工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update staff_table k</span><br><span class="line">set salary&#x3D;salary*1.05</span><br><span class="line">#select staff_id </span><br><span class="line">#from staff_table</span><br><span class="line">where salary&lt;(select avg(salary) from staff_table</span><br><span class="line"> w);</span><br><span class="line">#没提工资</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 终版</span><br><span class="line">create view tmpstaff_table as select avg(salary) as avgsalary from staff_table;</span><br><span class="line">update staff_table k</span><br><span class="line">set k.salary&#x3D;k.salary*1.05</span><br><span class="line">where k.salary&lt;(select avgsalary from tmpstaff_table);</span><br></pre></td></tr></table></figure><p>習題：</p><p>1.檢索出所有倉庫的平均面積</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">avg(area) </span><br><span class="line">from </span><br><span class="line">warehouse ;</span><br></pre></td></tr></table></figure><p>2.檢索出每個倉庫中工資多於1220元的職工個數</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">warehouse_num,count(*) </span><br><span class="line">from </span><br><span class="line">staff_table </span><br><span class="line">where </span><br><span class="line">salary&gt;&#39;1220&#39; </span><br><span class="line">group by </span><br><span class="line">warehouse_num ;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select w.name &#39;领导&#39;,k.name from employee w,employee k where w.employee_id&#x3D;k.manager</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>2020.10.29</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure inputInfo()</span><br><span class="line">begin</span><br><span class="line">-- 1. 先求gradetable中 的总分 </span><br><span class="line">-- 2. 然后根据专业 筛选出某专业最高分</span><br><span class="line">        -- 当专业相同时 总分最高的人的 id</span><br><span class="line">-- 3. 将最高分赋值给变量 插入 maxscore</span><br><span class="line">    -- 获取最高分的同学的 全部信息</span><br><span class="line">-- 4. </span><br><span class="line">-- set maxscore&#x3D;sum(math+eng+clan+java);</span><br><span class="line">declare i int default 0;</span><br><span class="line">declare total float default 0.00;</span><br><span class="line">declare tId int default 1;</span><br><span class="line">declare tprj varchar(10) default &#39;&#39;;</span><br><span class="line">-- declare tmax float default 0.00;</span><br><span class="line">-- 学科</span><br><span class="line">declare tmath float default 0.00;</span><br><span class="line">declare teng float default 0.00;</span><br><span class="line">declare tclan float default 0.00;</span><br><span class="line">declare tjava float default 0.00;</span><br><span class="line"></span><br><span class="line">declare curl cursor for select profess,id,math,eng,clan,java from gradetable;</span><br><span class="line">declare continue handler for sqlstate &#39;02000&#39; set i&#x3D;1;</span><br><span class="line">open curl;</span><br><span class="line">fetch curl into tId,tmath,teng,tclan,tjava,tprj;</span><br><span class="line">while i!&#x3D;1 do</span><br><span class="line">    set total&#x3D;sum (tmath,teng,tclan,tjava);</span><br><span class="line">    fetch curl into tId,tmath,teng,tclan,tjava,tprj;</span><br><span class="line">end while;</span><br><span class="line">close curl;</span><br><span class="line">select total;</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 得出总分 so easy </span><br><span class="line">select id,sname,round(math+eng+clan+java,1) as score from gradetable;</span><br><span class="line">-- group by 求出的 最高值只有一个 ×</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">show tables from mysql;</span><br><span class="line">#在一个库中 查看其它库（mysql）的表。</span><br><span class="line"></span><br><span class="line">select database();</span><br><span class="line">#查看 我在哪个库中。</span><br><span class="line"></span><br><span class="line">desc staff_table ;</span><br><span class="line">#看表的结构</span><br><span class="line"></span><br><span class="line">select * from 表名;</span><br><span class="line">#想看表中有哪些数据  *所有的字段 默认表的顺序</span><br><span class="line"></span><br><span class="line">insert into 表名 (id,name,gender) values (&#39;988&#39;,&#39;li&#39;,&#39;male&#39;);</span><br><span class="line">#插入数据</span><br><span class="line"></span><br><span class="line">alter table supply_table add key (id);</span><br><span class="line">#追加主键</span><br><span class="line">alter table supply_table drop key;</span><br><span class="line">#delete all key; </span><br><span class="line">#if just wanna delete one key add(id);</span><br><span class="line"></span><br><span class="line">select version();</span><br><span class="line">#查看客户端版本</span><br><span class="line"></span><br><span class="line">select supply_id from Supply_table;</span><br><span class="line">#查询表中的单个字段  多个字段 逗号隔开即可</span><br><span class="line"></span><br><span class="line">#区分关键字 还是 字段 用折中号 &#96;  &#96;;</span><br><span class="line"></span><br><span class="line">select const;#查找常量；</span><br><span class="line">select 5*6;#查询表达式</span><br><span class="line">select version();#查询函数</span><br><span class="line">select staff_id as 员工号 from staff_table;</span><br><span class="line">#起别名 使表看起来更直观   as可省略</span><br><span class="line"></span><br><span class="line">select distinct staff_id from staff_table;</span><br><span class="line">&#x2F;* 去重 重复的值 不显示*&#x2F;</span><br><span class="line"></span><br><span class="line">select ifnull(可能为空的属性,如果为空显示多少) as 别名;</span><br><span class="line">&#x2F;*如果是null 拼接的时候 将全部是null  给个默认值能好看点？*&#x2F;</span><br><span class="line">-- 別名</span><br><span class="line">select salary 工資 from staff_table;</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">#③查询列表</span><br><span class="line">from</span><br><span class="line">#①表名</span><br><span class="line">where</span><br><span class="line">#②筛选条件</span><br><span class="line">order by </span><br><span class="line">asc | desc #(升序或者降序)</span><br><span class="line">warehouse_num,salary desc;</span><br><span class="line">#尽量避免在子查询中排序，在&#x3D;&#x3D;最终查询&#x3D;&#x3D;排序即可</span><br><span class="line">#有些数据库 禁止在子查询中排序</span><br><span class="line">&#x2F;* 完整格式  语法 *&#x2F;</span><br><span class="line"></span><br><span class="line">select length(id) 字节长度&#x2F;*别名*&#x2F;;#字节长度</span><br><span class="line"></span><br><span class="line">select 函数名(实参列表);#函数的调用</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">staff_id,employee_id </span><br><span class="line">from </span><br><span class="line">staff_table,employee </span><br><span class="line">where </span><br><span class="line">staff_table.staff_id&#x3D;employee.employee_id;</span><br><span class="line">#将两个表的 一样id的进行匹配。</span><br><span class="line"></span><br><span class="line">alter table stduent rename student;</span><br><span class="line">#改表名  旧表名--&gt;新表名</span><br><span class="line"></span><br><span class="line">alter table studenttable modify score int;</span><br><span class="line">#改字段的数据类型  改空值</span><br><span class="line"></span><br><span class="line">alter table studenttable change name student_name varchar(8);</span><br><span class="line">#改变表的字段名  change 旧的字段名，新的字段名 类型(长度)</span><br><span class="line"></span><br><span class="line">alter table studenttable add memo varchar(50);</span><br><span class="line">#添加字段</span><br><span class="line"></span><br><span class="line">alter table studenttable drop memo;</span><br><span class="line">#删除字段</span><br><span class="line"></span><br><span class="line">delete from supply_table where id&#x3D;1;</span><br><span class="line">#删除表中的元素</span><br><span class="line"></span><br><span class="line">#对关键字的修改</span><br><span class="line">select * from orders limit 3,2;</span><br><span class="line">#从哪开始的几个 --&gt; mysql</span><br><span class="line"></span><br><span class="line">insert into tmpwarehouse select * from staff_table where salary&gt;1230;</span><br><span class="line">#将别的表复合条件的信息 导入该表</span><br><span class="line"></span><br><span class="line">update 表名 set 属性字段 where 条件;#可多项修改</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -pGuoyunle1. training -e &quot;desc warehouse&quot; -- -e 之后 马上要执行的语句</span><br><span class="line">-- 可以放一个procedure</span><br><span class="line">create user &#39;father&#39;@&#39;localhost&#39; identified by&#39;myson&#39;;</span><br><span class="line">grant insert on *.* to &#39;father&#39;@&#39;localhost&#39;;</span><br><span class="line">-- 增加插入权限</span><br><span class="line">revoke create on *.* from &#39;li&#39;@&#39;localhost&#39;;</span><br><span class="line">-- 收回创建权限</span><br><span class="line"></span><br><span class="line">grant select,create,insert on training.* to &#39;li&#39;@&#39;localhost&#39; identified by&#39;apple&#39;;</span><br><span class="line"></span><br><span class="line">-- 远程访问</span><br><span class="line">update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;ma&#39;;</span><br><span class="line">-- 控制面板 重启MySQL进程</span><br><span class="line"></span><br><span class="line">-- 数据库 import export</span><br><span class="line">import source c:\_train.sql </span><br><span class="line">-- databases XX1,XX2,XX3,XX4,XX5  导出多个库</span><br><span class="line"></span><br><span class="line">-- 导出数据库</span><br><span class="line">mysqldump -hlocalhost -uroot -pGuoyunle1. signinfo &gt; d:&#x2F;book.sql</span><br></pre></td></tr></table></figure><p>args [ ]命令行参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 同版本迁移</span><br><span class="line">-- 远程 本地</span><br><span class="line">C:\ mysqldump  -h192.168.188  -uroot -pcdopen mybase1 | mysql localhost -uma -papple;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>idstate procedure</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter &#x2F;&#x2F;</span><br><span class="line">create procedure addaccount()</span><br><span class="line">begin</span><br><span class="line">declare i int default 888888888;</span><br><span class="line">while i&lt;&#x3D;888900000 do</span><br><span class="line">    insert into accountstate values(i,&#39;0&#39;);</span><br><span class="line">    set i&#x3D;i+1;</span><br><span class="line">end while;</span><br><span class="line">end &#x2F;&#x2F;</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\99036\Desktop\Snipaste_2021-01-18_22-53-36.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-数据与数据处理&quot;&gt;&lt;a href=&quot;#1-数据与数据处理&quot; class=&quot;headerlink&quot; title=&quot;1.数据与数据处理&quot;&gt;&lt;/a&gt;1.数据与数据处理&lt;/h2&gt;&lt;h4 id=&quot;1-1数据&quot;&gt;&lt;a href=&quot;#1-1数据&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="database" scheme="http://example.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Java核心卷技术</title>
    <link href="http://example.com/2021/04/29/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2021/04/29/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E6%8A%80%E6%9C%AF/</id>
    <published>2021-04-29T08:09:41.000Z</published>
    <updated>2021-04-29T12:52:04.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-程序设计环境"><a href="#第二章-程序设计环境" class="headerlink" title="第二章 程序设计环境"></a>第二章 程序设计环境</h2><h3 id="2-1-安装Java开发工具包"><a href="#2-1-安装Java开发工具包" class="headerlink" title="2.1 安装Java开发工具包"></a>2.1 安装Java开发工具包</h3><ol><li>JDK： Java Development Kit</li><li>SDK：Software Development Kit  –&gt;1.2~1.4版本</li><li>Java EE：Java Enterprise Edition</li><li>Java ME：Micro Edition</li><li>Java SE：Standard Edition</li><li>Java2SE SDK 5.0：Java 2 Standa Edition Software Development Kit</li><li>==X86（32位）==     ==X64（64位）==<blockquote><p>Java程序启动Java虚拟机。虚拟机执行编译器放在class文件中的字节码<br>编译时 文件名–&gt; Welcome.java 运行时 类名–&gt; Welcome</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chooser=<span class="keyword">new</span> JFileChooser();</span><br><span class="line">chooser.setCurrentDirectory(<span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WIDTH=<span class="number">300</span>;<span class="comment">// 类常量</span></span><br><span class="line"></span><br><span class="line">exitItem.addActionListener(event -&gt; System.exit(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></li></ol><p><strong>此处跳过Java applet</strong></p><h2 id="第三章-Java基本程序设计结构"><a href="#第三章-Java基本程序设计结构" class="headerlink" title="第三章 Java基本程序设计结构"></a>第三章 Java基本程序设计结构</h2><h3 id="一个简单的Java程序"><a href="#一个简单的Java程序" class="headerlink" title="一个简单的Java程序"></a>一个简单的Java程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>关键字 public称为<strong>访问修饰符</strong> （access modifier）这些修饰符用于控制程序的其他部分对这段代码的访问级别</li><li>关键字 class 表明Java程序中的全部内容都包含在类中。**将类作为一个加载程序逻辑的容器 ** </li><li>==main方法必须声明为public== </li><li>System.out 是<strong>对象</strong> 的println <strong>方法</strong>。  ”.“  用于调用方法 ==&gt; 方法即使没有参数也需要使用空括号</li><li>Java使用的通用语法 –&gt;  ==object.method(parameters);==</li></ol></blockquote><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ~ 2 147 484 647（正好超过20亿）</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr></tbody></table><p><em>Java中 整数的范围与运行Java代码的机器无关。解决了软件从一个平台移植到另一个平台的不同操作系统进行移植给程序员带来的诸多问题。</em></p><ol><li>0x 十六进制</li><li>0b 二进制  1_000_000 | 0b1111_0100_0010</li><li>0 八进制</li><li>4000000000L long类型</li></ol><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>有效位数6~7位</td></tr><tr><td>double</td><td>8字节</td><td>有效数位15位</td></tr></tbody></table><ol><li>float类型数值 有后缀 <strong>f</strong> 没有后缀<strong>f</strong>的 默认为<strong>double</strong>类型。</li><li>Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN  –&gt; 正无穷 负无穷 NaN</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x==Double.NaN)<span class="comment">// is never true</span></span><br><span class="line"><span class="comment">//所有“非数值”的值都认为是不同的。</span></span><br><span class="line"><span class="comment">// 但是可以使用Double.NaN方法</span></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(x))<span class="comment">// 检查x是不是一个数</span></span><br></pre></td></tr></table></figure><p>==警告==<br>**<em>浮点数值采用二进制系统表示，而在二进制系统中无法精确表示分数1/10</em> **<br>如果计算中不允许有任何舍入应用–&gt; BigDecimal类</p><blockquote><p>题外话 **<em>加粗倾斜</em> **    星+ 空格 +星 星</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u00A0 is a new line</span></span><br><span class="line"><span class="comment">//\u00A0 会被替换为换行符</span></span><br><span class="line"><span class="comment">// look inside c:\users 会报语法错误 \u后面没有跟四位16进制数</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>转义序列</th><th>名称</th><th>Unicode值</th></tr></thead><tbody><tr><td>\b</td><td>退格</td><td>\u0008</td></tr><tr><td>\t</td><td>制表</td><td>\u0009</td></tr><tr><td>\n</td><td>换行</td><td>\u000a</td></tr><tr><td>\r</td><td>回车</td><td>\u000d</td></tr><tr><td>\“</td><td>双引号</td><td>\u0022</td></tr><tr><td>\‘</td><td>单引号</td><td>\u0027</td></tr><tr><td>\\</td><td>反斜杠</td><td>\u005c</td></tr></tbody></table><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ol><li><strong>final声明一个常量 常量只被赋值一次。尽量全部大写。</strong></li><li>类常量–&gt; 可使用关键字 static final 。这个常量可在一个类中的多个方法中使用。   ==疑问：== 直接设全局变量不就行了？</li><li>const 目前并没有使用</li></ol><blockquote><p>println方法处理的是System.out对象 而Math类中的sqrt方法处理的不是对象 这样的方法称为<strong>静态方法</strong></p></blockquote><p><em>StrictMath类</em> <a href="http://www.netlib.org/fdlibm">www.netlib.org/fdlibm</a></p><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>==图片待插入==</p><h4 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x=<span class="number">9.997</span>;</span><br><span class="line"><span class="keyword">int</span> nx=(<span class="keyword">int</span>)x; <span class="comment">// --&gt; 9 截断</span></span><br><span class="line"><span class="keyword">int</span> nx=(<span class="keyword">int</span>)Math.round(x);<span class="comment">// Math.round()返回的是long型 需要强转成int</span></span><br><span class="line"><span class="comment">// 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换</span></span><br><span class="line">x+=<span class="number">3.5</span>；</span><br><span class="line">(<span class="keyword">int</span>)(x+<span class="number">3.5</span>);</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><blockquote><p>x &lt; y ? x:y;</p></blockquote><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例： 如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则返回1，否则返回0.</span></span><br><span class="line"><span class="comment">// 利用&amp; 结合2的幂，可以把其他位掩掉，而保留其中一位。</span></span><br><span class="line"><span class="keyword">int</span> fourthBitFromRight=(n &amp; <span class="number">0b1000</span>)/ob1000;</span><br></pre></td></tr></table></figure><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p><strong>p44</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String b=a.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// &quot;HEl&quot;</span></span><br><span class="line"><span class="comment">// 容易计算子串的长度 b.substring(a,b);的长度为 b-a；</span></span><br></pre></td></tr></table></figure><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果需要把多个字符串放在一起 用一个定界符分开，可以使用静态join方法</span></span><br><span class="line">String all=String.join(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;l&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;s/m/l&quot;</span></span><br></pre></td></tr></table></figure><h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><blockquote><p>Java文档中将String类对象称为<strong>不可变字符串</strong>,字符串”hello”永远是hello，通过修改字符串变量，让它引用另一个字符串。<br><em>如同可以将存放3的数值变量改成存放4一样</em></p></blockquote><h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.equals(t);</span><br><span class="line"><span class="string">&quot;hello&quot;</span>.equals(s);<span class="comment">//可以是字符串变量，可以是字面量</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 不用==判断字符串相等。比较的是地址</span></span><br></pre></td></tr></table></figure><h4 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h4><p><strong>p49</strong></p><h4 id="3-10数组"><a href="#3-10数组" class="headerlink" title="3.10数组"></a>3.10数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line"><span class="keyword">int</span> a[];</span><br></pre></td></tr></table></figure><h5 id="3-10-1-for-each-循环"><a href="#3-10-1-for-each-循环" class="headerlink" title="3.10.1 for each 循环"></a>3.10.1 for each 循环</h5><blockquote><p>可以用来依次处理数组中的每个元素（其他类型的元素集合亦可）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增强for循环的语句格式：</span></span><br><span class="line"><span class="comment">// 定义一个变量暂存集合中的每一个元素，并执行相应语句</span></span><br><span class="line"><span class="keyword">for</span>(variable : collection) statement</span><br></pre></td></tr></table></figure><blockquote><p><strong>数组长度为0 与 null不同</strong>！</p></blockquote><h5 id="3-10-3-数组拷贝"><a href="#3-10-3-数组拷贝" class="headerlink" title="3.10.3 数组拷贝"></a>3.10.3 数组拷贝</h5><p>Arrays类的copyOf方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] cNum=Arrays.copyOf(num,num.length);</span><br><span class="line"><span class="comment">// 数值型 多余值--》0  布尔型 --》 false</span></span><br></pre></td></tr></table></figure><p>彩票练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lotteryDrawing</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;how many nums do you need to draw&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> k=in.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;what is the highest num you can draw?&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> n=in.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill an array with num 1 2 3 4 ...n </span></span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// draw k nums and put them into asecond array</span></span><br><span class="line"><span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line"><span class="comment">//make a random index between () and n-1</span></span><br><span class="line"><span class="keyword">int</span> r=(<span class="keyword">int</span>)(Math.random()*n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pick the element at the random location</span></span><br><span class="line">result[i]=nums[r];</span><br><span class="line"></span><br><span class="line"><span class="comment">// move the last elemetn into the random location</span></span><br><span class="line">nums[r]=nums[n-<span class="number">1</span>];</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print the sorted array</span></span><br><span class="line">Arrays.sort(result);</span><br><span class="line">System.out.println(<span class="string">&quot;bet the follwing combination.it&#x27;ll make you rich&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r:result)</span><br><span class="line">System.out.println(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掠过部分 待补齐</p><hr><h2 id="第四章-对象和类"><a href="#第四章-对象和类" class="headerlink" title="第四章 对象和类"></a>第四章 对象和类</h2><h3 id="4-1面向对象的设计概念"><a href="#4-1面向对象的设计概念" class="headerlink" title="4.1面向对象的设计概念"></a>4.1面向对象的设计概念</h3><h4 id="4-1-1类"><a href="#4-1-1类" class="headerlink" title="4.1.1类"></a>4.1.1类</h4><blockquote><p>类是制作小甜饼的切割机，对象是小甜饼。由类构造(constract)对象的过程称为创建类的实例(instance)<br>封装(encapsulation,有时称为数据隐藏)。 对象中的数据称为<strong>实例域(instance field)</strong>,操纵数据的过程称为<strong>方法(method)<strong>。<br>实现封装的关键在于，绝对不能让<em>类中的方法</em>直接地访问</strong>其他类</strong>的实例域。<br>Object是所有类的超类<br>在拓展一个已有类时，这个拓展后的新类具有所拓展的类的全部属性和方法。在新类中只需提供适用于这个新类的新方法和数据域就可以了。*<em>通过拓展一个类来建立另外一个类的过程称为</em>继承(inheritance)* **</p></blockquote><h4 id="4-1-2对象"><a href="#4-1-2对象" class="headerlink" title="4.1.2对象"></a>4.1.2对象</h4><p>对象的三个主要特征</p><ul><li>对象的行为  –&gt; 可以对对象施加哪些操作，或可以对对象施加哪些方法。</li><li>对象的状态 –&gt; 当施加那些方法时，对象如何响应？</li><li>对象的标识 –&gt; 如何辨别具有相同行为与状态不同的对象？<h4 id="4-1-3-识别类"><a href="#4-1-3-识别类" class="headerlink" title="4.1.3 识别类"></a>4.1.3 识别类</h4><blockquote><p>首先从设计类开始，然后再往每个类中添加方法<br><strong>找名词，找动词</strong></p></blockquote><h4 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h4>最常见的有：</li><li>依赖</li><li>聚合</li><li>继承<blockquote><p>如果一个类大的方法 操纵另一个类的对象 –&gt; 依赖   <strong>尽可能将相互依赖的类减少</strong>  ==俗称低耦合==。（B的改变 不会导致A产生任何BUG）<br>类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些自己的功能。</p></blockquote><h3 id="4-2使用预定义类"><a href="#4-2使用预定义类" class="headerlink" title="4.2使用预定义类"></a>4.2使用预定义类</h3><h4 id="4-2-1-对象和对象变量"><a href="#4-2-1-对象和对象变量" class="headerlink" title="4.2.1 对象和对象变量"></a>4.2.1 对象和对象变量</h4><blockquote><p>要想使用对象</p><ol><li>构造对象</li><li>指定其初始状态</li><li>对对象应用方法</li></ol><p>Java中使用构造器(constructor)构造新实例。 –》 构造器是一种特殊的方法<br>通常希望构造的对象可以多次使用，因此需要将对象存放在一个变量中</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象与对象变量之间存在着一个重要的区别。</span></span><br><span class="line">Date deadline;<span class="comment">//deadline doesn&#x27;t refer to any object</span></span><br><span class="line"><span class="comment">// 可以引用Date类型的对象，但是一定要认识到：</span></span><br><span class="line"><span class="comment">//==deadline不是一个对象== 实际上也没有 引用对象。 </span></span><br><span class="line"><span class="comment">//**不能将任何Date方法应用到这个变量。</span></span><br><span class="line">s=deadline.toString();<span class="comment">// --&gt; 将产生编译错误</span></span><br></pre></td></tr></table></figure><p>==一个对象变量并没有实际包含一个对象，而仅仅引用一个对象==</p><p><del>掠过localtime</del></p><h3 id="4-3-用户自定义类"><a href="#4-3-用户自定义类" class="headerlink" title="4.3 用户自定义类"></a>4.3 用户自定义类</h3><h4 id="4-3-1-Employee类"><a href="#4-3-1-Employee类" class="headerlink" title="4.3.1 Employee类"></a>4.3.1 Employee类</h4><blockquote><p>一个源文件中 只能有<strong>一个</strong>公有类 可以有<strong>多个</strong>私有类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;  <span class="comment">//1.实例域就是字符串对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary;  <span class="comment">//2.</span></span><br><span class="line"><span class="keyword">private</span> LocalDate hireDay;<span class="comment">//3.实例域就是对象</span></span><br><span class="line"><span class="comment">// 关键字private确保只有employee类自身的方法能访问这些实例域</span></span><br></pre></td></tr></table></figure><p>对于构造器，目前只需要记住：</p><ul><li>构造器与类同名</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个、一个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作一起调用</li></ul><p>==<strong>必须注意，在所有的方法中不要命名与实例域同名的变量！</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要在构造器定义与实例域重名的局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n,<span class="keyword">double</span> s...)</span></span>&#123;</span><br><span class="line">String name=n;</span><br><span class="line"><span class="keyword">double</span> salary=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-5-隐式参数和显示参数"><a href="#4-3-5-隐式参数和显示参数" class="headerlink" title="4.3.5 隐式参数和显示参数"></a>4.3.5 隐式参数和显示参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个隐式参数(implicit)，是方法名前的 Employee类对象。</span></span><br><span class="line"><span class="comment">// 第二个显示参数(explicit)，位于方法名后面括号中的数值</span></span><br><span class="line">number007.raiseSalary(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">this</span>.raiseSalary(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>在每一个方法中，关键字this表示隐式参数。</strong>，这样可以将实例域与局部变量明显的区分开。==？==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">return.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的访问器方法，因为他们只返回实例域值，又称为–》域访问器。</p><p>有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p><ul><li>一个私有的数据域</li><li>一个公有的域访问器方法</li><li>一个公有的域更改器方法</li></ul><hr><p>P110页 有些高深</p><h4 id="4-3-6-封装的优先"><a href="#4-3-6-封装的优先" class="headerlink" title="4.3.6 封装的优先"></a>4.3.6 封装的优先</h4><blockquote><p>更改器方法可以执行错误检查，然而<strong>直接对域进行赋值</strong>将不会进行这些处理。</p></blockquote><h4 id="4-3-7-基于类的访问权限"><a href="#4-3-7-基于类的访问权限" class="headerlink" title="4.3.7 基于类的访问权限"></a>4.3.7 基于类的访问权限</h4><blockquote><p>一个方法可以访问所属类的所有对象的私有数据</p></blockquote><h4 id="4-3-8-私有方法"><a href="#4-3-8-私有方法" class="headerlink" title="4.3.8 私有方法"></a>4.3.8 私有方法</h4><blockquote><p>Java中，实现一个私有方法，只需将关键字由public 改为 private即可</p></blockquote><p>如果改用其他方法实现相应的操作，只要方法是私有的，可以将其删去；如果是公有的，不能删去，因为其他的代码可能依赖他。</p><h4 id="4-3-9-final实例域"><a href="#4-3-9-final实例域" class="headerlink" title="4.3.9 final实例域"></a>4.3.9 final实例域</h4><blockquote><p>final大都应用于*基本(primitive)<em>类型域，或</em>不可变(immutable)*域<br>（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例：String）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringBuilder evaluations;</span><br><span class="line"><span class="comment">// 在构造器中会初始化为：</span></span><br><span class="line">evaluations = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p>final关键字只是表示存储在evaluations变量中的对象引用不会再指示其他StringBuilder对象，不过这个类可以更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveGoldStar</span><span class="params">()</span></span>&#123;</span><br><span class="line">evaluations.append(LocalDate.now()+<span class="string">&quot;:Gold star!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-静态域和静态方法"><a href="#4-3-静态域和静态方法" class="headerlink" title="4.3 静态域和静态方法"></a>4.3 静态域和静态方法</h3><h4 id="4-4-1-静态域"><a href="#4-4-1-静态域" class="headerlink" title="4.4.1 静态域"></a>4.4.1 静态域</h4><p>每个类中只有一个静态域(static)。==而每一个对象对于所有的实例域却都有自己的一份拷贝==。如果有1000个Employee类的对象，则有1000个实例域id，但是只有一个静态域nextId。即使没有一个雇员对象，静态域nectId也存在。<strong>它属于类，而不属于任何独立的对象</strong>。</p><h4 id="4-4-2-静态常量"><a href="#4-4-2-静态常量" class="headerlink" title="4.4.2 静态常量"></a>4.4.2 静态常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">····</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI=<span class="number">3.1415926535807</span>;</span><br><span class="line">&#125;</span><br><span class="line">····</span><br></pre></td></tr></table></figure><p>如果没有static关键字，PI就变成了Math类的一个实例域</p><blockquote><p>每个类对象都可以对公由于进行修改，所以最好不要将域设计为public。然而，公有常量（final域）没问题，</p></blockquote><h4 id="4-4-3-静态方法"><a href="#4-4-3-静态方法" class="headerlink" title="4.4.3 静态方法"></a>4.4.3 静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">// 在运算时 不适用任何对象  --》 没有隐式参数</span></span><br><span class="line"><span class="comment">// 对象变量.方法  *应该是*</span></span><br><span class="line">Math.pow(x,a);</span><br></pre></td></tr></table></figure><p>静态方法<strong>不能操作对象。但是可以访问自身类中的静态域。</strong></p><p>在下面给两种情况下使用静态方法：</p><ul><li>一个方法不需要访问对象状态，其所需参数都是通过显示参数提供的（例：Math.pow）</li><li>一个方法只需要访问类的静态域（如：Employee.getNextId）</li></ul><blockquote><p>属于类 但不属于类对象的变量和函数。</p></blockquote><h4 id="4-4-4-工厂方法"><a href="#4-4-4-工厂方法" class="headerlink" title="4.4.4 工厂方法"></a>4.4.4 工厂方法</h4><h4 id="4-4-5-main方法"><a href="#4-4-5-main方法" class="headerlink" title="4.4.5 main方法"></a>4.4.5 main方法</h4><h3 id="4-5-方法参数"><a href="#4-5-方法参数" class="headerlink" title="4.5 方法参数"></a>4.5 方法参数</h3><ol><li>按值调用（call by value） –》 表示方法接收的是调用者提供的值</li><li>按引用调用（call by reference）–》 表示方法接收的是调用者提供的变量地址</li></ol><p>一个方法可以<strong>修改</strong>传递引用所对应的变量值，而不能修改传递至调用所对应的变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> percent=<span class="number">10</span>;</span><br><span class="line">harry.raiseSalary(percent);</span><br><span class="line">*************************************</span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span><span class="comment">//doesn&#x27;t work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">3</span>*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">tripleValue(percent);</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(Employee x)</span><span class="comment">// work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">harry=<span class="keyword">new</span> Employee(...);</span><br><span class="line">tripleValue(harry);</span><br></pre></td></tr></table></figure><p>方法参数公有两种类型：</p><ul><li>基本数据类型（数字、布尔类型）</li><li>对象引用</li></ul><ol><li> 调用这个方法后，percent的值还是10.</li></ol><ul><li>x被初始化为percent值的一个拷贝 –》 10</li><li>x被乘以3等于30。但是percent仍然为10.</li><li>方法结束后，参数变量x不再使用，</li></ul><ol start="2"><li>可以实现</li></ol><ul><li>x被初始话为harry值的拷贝，这里是一个对象的引用。</li><li>raiseSalary方法应用于这个对象引用。x和harry同时引用那个Employee对象的薪金增加了200%。</li><li>方法结束后，参数变量x不在使用。对象变量harry继续引用那个薪金增加3倍的雇员对象</li></ul><p><strong>总结 Java中方法参数的使用情况：</strong></p><ul><li>一个方法不能修改一个基本数据类型的参数（数值或布尔型）</li><li>一个方法可以改变一个对象参数的装态</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p>==P120== 需要复盘 –》 比较复杂</p><h3 id="4-6-对象构造"><a href="#4-6-对象构造" class="headerlink" title="4.6 对象构造"></a>4.6 对象构造</h3><h4 id="4-6-1-重载"><a href="#4-6-1-重载" class="headerlink" title="4.6.1 重载"></a>4.6.1 重载</h4><p>Java允许重载任何方法，不只是构造器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 类</span></span><br><span class="line">indexOf(<span class="keyword">int</span>);</span><br><span class="line">indexOf(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">indexOf(String);</span><br><span class="line">indexOf(String,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>要完整地描述一个方法，需要指出方法名以及参数类型。–&gt;方法的签名(signature)。 <strong>返回类型不是方法签名的一部分</strong></p><h4 id="4-6-1-默认域初始化"><a href="#4-6-1-默认域初始化" class="headerlink" title="4.6.1 默认域初始化"></a>4.6.1 默认域初始化</h4><p>构造器中没有显示地给域赋初值，就会被自动赋为默认值：数值为0，布尔值为false，对象引用为null。 ==对域进行初始化==</p><h4 id="4-6-3-无参构造器"><a href="#4-6-3-无参构造器" class="headerlink" title="4.6.3 无参构造器"></a>4.6.3 无参构造器</h4><ol><li>如果编写一个类，没有编写构造器，系统会自动提供一个无参构造器。–》默认值</li><li>如果至少提供了一个，但没提供无参构造器，构造对象时无参–》<strong>不合法</strong>。<h4 id="4-6-4-显示域初始化"><a href="#4-6-4-显示域初始化" class="headerlink" title="4.6.4 显示域初始化"></a>4.6.4 显示域初始化</h4>可以通过这种方式进行初始化..   为什么觉得有点2b<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id=assignId();</span><br><span class="line">· · ·</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=nextId;</span><br><span class="line">nextId++;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>中间滤过 4.6.5 参数名</p><h4 id="4-6-6-调用另一个构造器。"><a href="#4-6-6-调用另一个构造器。" class="headerlink" title="4.6.6  调用另一个构造器。"></a>4.6.6  调用另一个构造器。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// call Employee(String,double)</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span>,s);</span><br><span class="line">nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用同一个类的另一个构造器。</p><h4 id="4-6-7-初始化块（不常见）"><a href="#4-6-7-初始化块（不常见）" class="headerlink" title="4.6.7 初始化块（不常见）"></a>4.6.7 初始化块（不常见）</h4><h4 id="4-6-8-对象析构域finalize方法"><a href="#4-6-8-对象析构域finalize方法" class="headerlink" title="4.6.8 对象析构域finalize方法"></a>4.6.8 对象析构域finalize方法</h4><p>垃圾回收机制</p><h3 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h3><h4 id="4-7-1-类的导入"><a href="#4-7-1-类的导入" class="headerlink" title="4.7.1  类的导入"></a>4.7.1  类的导入</h4><h4 id="4-7-2-静态导入"><a href="#4-7-2-静态导入" class="headerlink" title="4.7.2 静态导入"></a>4.7.2 静态导入</h4><h4 id="4-7-3-将类放入包中"><a href="#4-7-3-将类放入包中" class="headerlink" title="4.7.3 将类放入包中"></a>4.7.3 将类放入包中</h4><p>·<br>·     中间掠过些简单概念 后续感兴趣再阅读。==P127-144==<br>·</p><h3 id="4-10-类设计技巧"><a href="#4-10-类设计技巧" class="headerlink" title="4.10 类设计技巧"></a>4.10 类设计技巧</h3><ol><li>一定要保证数据私有<blockquote><p>当数据保持私有时，他们表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测。</p></blockquote></li><li>一定要对数据初始化</li><li>不要再类中使用过多的基本类型</li><li>不是所有的域都需要独立的域访问器和域修改器</li><li>将职责过多的类进行分解  –》 可以将一个复杂的类 分为两个更简单的类</li><li>类名和方法名能体现他们的职责</li><li>优先使用不可变的类</li></ol><h2 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h2><p><strong>主要知识点：</strong></p><ol><li>类、超类和子类</li><li>Object：所有类的超类</li><li>泛型数组列表</li><li>对象包装与自动装箱</li><li>参数数量可变的方法</li><li>枚举类</li><li>反射(reflection)</li><li>继承的设计技巧<h3 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h3><h4 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h4>关键字extends表示继承，表明正在构造的新类派生于一个已存在的类。<br>已存在的类称为超类(superclass)、基类(base class)或父类(parent class);<br>新类称为子类(subclass)、派生类(derived class)或孩子类(child class)。<blockquote><p>tips: 没有c++中的私有继承  只有公有继承<br>tips: 超类不一定比子类功能多<br>tips: 应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中</p></blockquote></li></ol><h4 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h4><p>例：Manager类中的getSalary方法应该返回薪水和奖金的综合，为此，需要提供过一个新方法来覆盖(override)超类中的这个方法。(Employee-超类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>方法一：</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary + bonus;<span class="comment">// won&#x27;t work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manager类的getSalary方法 <strong>不能够直接访问超类的私有域</strong> (<strong>private int salary</strong>)。如果一定要访问私有域，就必须借助于公有的接口，Employee中的公有方法<strong>getSalary</strong>正是这样的接口。<br><del>方法二：</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> baseSalary = getSalary();<span class="comment">//still won&#x27;t work</span></span><br><span class="line"><span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manager类中也有getSalary方法，一直调用自己。</p><blockquote><p>要调用超类中的getSalary方法。使用特定关键字==super==解决问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.getSalary();</span><br></pre></td></tr></table></figure><p>正确方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name,<span class="keyword">double</span> salary,<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">bonus=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> baseSalary = <span class="keyword">super</span>,getSalary();</span><br><span class="line"><span class="keyword">return</span> baseSalary+bonus;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-1-继承层次"><a href="#5-4-1-继承层次" class="headerlink" title="5.4.1 继承层次"></a>5.4.1 继承层次</h4><blockquote><p>由一个公共超类派生出来的所有类的集合被称为继承层次(inheritance hierarchy)<br>从某个特定的类型到其祖先的路径被称为该类的继承链(inheritance chain)。</p></blockquote><h4 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h4><blockquote><p>一个简单判断是否应该设计为继承关系的简单规则：“is-a”规则 –&gt; 它表明子类的每个对象也是超类的对象。<br>“is-a” 另一种表述是 置换法则：程序中出现超类对象的任何地方都可以用子类对象替换。<br>解释：每个经理都是雇员，反之不然。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e=<span class="keyword">new</span> Employee();</span><br><span class="line">e=<span class="keyword">new</span> Manager();<span class="comment">// can be used as well</span></span><br></pre></td></tr></table></figure><p>Java中，对象变量是多态的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manager boss =<span class="keyword">new</span> Manager();</span><br><span class="line">Employee[] staff=<span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>]=boss;</span><br></pre></td></tr></table></figure><p>变量staff[0]与boss引用同一个对象。==不就是变量赋值吗？== 编译器将staff[0]看成Employee对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boss.setBonus(<span class="number">5000</span>);<span class="comment">//ok</span></span><br><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">5000</span>);<span class="comment">//err</span></span><br><span class="line"><span class="comment">// staff[0] 声明的Employee对象  而setBonus是Manager类的方法</span></span><br></pre></td></tr></table></figure><p><strong>然而，不能将一个超类的引用赋值给子类变量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Manager m=staff[i];<span class="comment">//err</span></span><br></pre></td></tr></table></figure><p><strong>==警告== ：</strong><br>Java中，子类数组的引用可以转换成超类数组的引用，而不用强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manager[] managers=<span class="keyword">new</span> Manager[<span class="number">10</span>];</span><br><span class="line">Employee[] staff=managers;<span class="comment">//ok</span></span><br><span class="line"><span class="comment">// 编译器接纳了这个赋值操作</span></span><br><span class="line"><span class="comment">// 在这里staff[0]与manager[0]引用的是同一个对象，导致把一个普通雇员，归入经理行列中。</span></span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,....);</span><br><span class="line"><span class="comment">//这样做不会有问题</span></span><br></pre></td></tr></table></figure><p>==这是一个很忌讳发生的情形==<br><strong>因为当调用manager[0].setBonus(1000)的时候，就会导致调用一个不存在的实例域，进而搅乱存储空间的内容。</strong></p><blockquote><p>会引发ArrayStoreException</p></blockquote><h4 id="5-1-6-理解方法的调用"><a href="#5-1-6-理解方法的调用" class="headerlink" title="5.1.6 理解方法的调用"></a>5.1.6 理解方法的调用</h4><p>P155 详细步骤</p><ol><li>获取备选方法</li><li>获取参数类型</li><li>如：private、static、final 方法或构造器 可以准确知道调用哪个方法。这种调用方式称为：静态绑定(static binding)。与之对应的是动态绑定，调用的方法依赖于隐式参数的实际类型。  <em>不是private、static、final –》 动态绑定</em></li><li>先根据动态绑定的实际类型查找，再超类。依次类推。  有虚拟机讲解 ==后待补== P156</li></ol><blockquote><p>如果子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。  不是super才能覆盖吗？？？<br>动态绑定的一个<strong>非常重要的特性</strong>：无需对现存的代码进行修改，就可以对程序进行扩展。<br>例：增加一个新类Executive，变量e（Employee类对象）引用这个类的对象，不需要对包含调用e.getSalary()的代码进行重新编译。<br>==警告==<br>再覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。否则，编译器将会把它解释为试图提供更严格的访问权限。 –》 private？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ?????</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getBuddy</span><span class="params">()</span></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Manager <span class="title">getBuddy</span><span class="params">()</span></span>&#123;···&#125;<span class="comment">// ok change return type</span></span><br><span class="line"><span class="comment">// 这两个getBuddy方法具有可协变的返回类型</span></span><br></pre></td></tr></table></figure><h4 id="5-1-7-阻止继承：final类和方法"><a href="#5-1-7-阻止继承：final类和方法" class="headerlink" title="5.1.7 阻止继承：final类和方法"></a>5.1.7 阻止继承：final类和方法</h4><p>不允许被拓展的类称为final类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Executive</span> <span class="keyword">extends</span> <span class="title">Manager</span></span>&#123;···&#125;</span><br></pre></td></tr></table></figure><p>方法也可以声明为final。这样做子类就不能覆盖这个方法。</p><blockquote><p>如果一个类声明为final，只有方法自动称为final，不包括域。</p></blockquote><p><strong>主要目的</strong>是：确保他们不会在子类中改变语义。</p><h4 id="5-1-8-强制类型转换"><a href="#5-1-8-强制类型转换" class="headerlink" title="5.1.8 强制类型转换"></a>5.1.8 强制类型转换</h4><p>类型转换的唯一原因：暂时护士对象的实际类型后，使用对象的全部功能。</p><blockquote><p>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类的变量，必须进行强制类型转换。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Manager boss =(Manager)staff[<span class="number">1</span>];<span class="comment">//err</span></span><br></pre></td></tr></table></figure><p>将产生一个：ClassCastException异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断类型 是否能转换成功</span></span><br><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager)</span><br><span class="line">&#123;</span><br><span class="line">boss=(Manager)staff[<span class="number">1</span>];</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>总能在继承层次内进行类型转换</li><li>在将超类转换成子类之前，应该使用instanceof进行检查</li><li><h4 id="5-1-9-抽象类"><a href="#5-1-9-抽象类" class="headerlink" title="5.1.9 抽象类"></a>5.1.9 抽象类</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//no implementation required</span></span><br></pre></td></tr></table></figure><p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以包含具体数据和具体方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展抽象类的两种方法：</p><ol><li>在抽象类中定义部分抽象类的方法或不定义抽象方法，这样必须将子类也标记为抽象类</li><li>定义全部的抽象方法，子类就不是抽象的</li></ol><blockquote><p>类即使不含抽象方法，也可以将类声明为抽象类。<br>==抽象类不能实例化==  如果一个类是抽象的，就不能创建这个类的对象。但是可以创建一个<strong>具体</strong>子类的对象。</p></blockquote><p>定义一个抽象类的对象变量，只能引用非抽象子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Student(<span class="string">&quot;vince vu&quot;</span>,<span class="string">&quot;Economics&quot;</span>);</span><br></pre></td></tr></table></figure><p>有些疑问P165.</p><hr><h4 id="5-1-10-受保护的访问"><a href="#5-1-10-受保护的访问" class="headerlink" title="5.1.10 受保护的访问"></a>5.1.10 受保护的访问</h4><p>4种常见的用于控制可见性的修饰符：</p><ol><li>仅对本类可见——private</li><li>对所有类可见——public</li><li>对本包和所有子类可见——protected</li><li>对本包可见——默认，不需要修饰符</li></ol><h3 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h3><p>可以使用Object类型变量引用任何类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e=<span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">3500</span>);</span><br></pre></td></tr></table></figure><p>Java中，只有基本类型不是对象。<br>所有数组类型，不管是对象数组还是基本类型数组都拓展了Object类。</p><h4 id="5-2-1-equals方法"><a href="#5-2-1-equals方法" class="headerlink" title="5.2.1 equals方法"></a>5.2.1 equals方法</h4><p>这个方法将判断两个对象是否具有相同的 引用。如果具有相同的引用，则一定是相等的。</p><p>==并没有很理解。。== P167</p><h4 id="5-2-2-相等测试与继承"><a href="#5-2-2-相等测试与继承" class="headerlink" title="5.2.2 相等测试与继承"></a>5.2.2 相等测试与继承</h4><p>如果隐式和显示参数不属于同一个类，equals方法将如何处理？<br>Java语言规范要求equals具有下面的特性：</p><ol><li>自反性：对于任何非空引用x，x.equals(x)应该返回true。</li><li>对称性：y.equals(X)为true，x.equals(y)也为true</li><li>传递性：x.equals(y),y.equals(z)则x.equals(z)为true</li><li>一致性：如果x，和y的引用没有变化，反复调用x.equals(y)应该返回同样的结果</li><li>对于任何非空引用x，x.equals(null)，应返回false。</li></ol><blockquote><p>AbstractSet 有两个子类，TreeSet和HashSet</p></blockquote><p>下面可以从两个截然不同的情况看一下这个问题：</p><ul><li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</li><li>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样就可以在不同子类的对象之间进行相等的比较。</li></ul><p>编写一个完美的equals方法的建议：</p><ol><li>显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</li><li>检测this与otherObject是否引用同一个对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li><li>检测otherObject是否为null，如果为null，返回false。这项检测是很有必要的。</li><li>比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就是用getClass检测：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass()!=otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 如果所有的子类都拥有统一的语义，就是用instanceof检测：</span></span><br><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li><li>将otherObject转换为相应的类类型变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName other =(ClassName)otherObject</span><br></pre></td></tr></table></figure></li><li>现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。<blockquote><p>对于数组类型的域，可以使用静态的Arrays.equals方法检测</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Boolean <span class="title">equals</span><span class="params">(type[]a,type[]b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果两个数组长度，内容都相同 true  数组类型-&gt; obj+ 基本数据类型</span></span></span><br><span class="line"><span class="function"><span class="comment">//2.</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(obj a,obj b)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果a和b都为null true；只有一个null，false。否则返回 a.equals(b)</span></span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-hashCode方法"><a href="#5-2-3-hashCode方法" class="headerlink" title="5.2.3 hashCode方法"></a>5.2.3 hashCode方法</h4><p>散列码(hash code)是由对象导出的一个整型值。</p><blockquote><p>由于hashcode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。<br>相同的字符串散列码相同。</p></blockquote><table><thead><tr><th>方法</th><th>含义</th><th>import</th></tr></thead><tbody><tr><td>int hashCode()</td><td>返回对象的散列码。散列码可以是任意的整数，包括正数或复数。相等的对象，散列码相同</td><td>java.util.Object 1.0</td></tr><tr><td>static int hash(Object… objects)</td><td>返回一个散列码，由提供的所有对象的散列码组合而得到</td><td>java.util.Objects 7</td></tr><tr><td>static int hashCode(Object a)</td><td>如果a为null返回0，否则返回a.hashCode()</td><td>java.util.Objects 7</td></tr><tr><td>static int hashCode((int</td><td>long</td><td>short</td></tr><tr><td>static int hashCode(type[] a)</td><td>计算数组a的散列码。组成这个数组的元素可以是obj+基本数据类型</td><td>java.util.Arrays 1.2</td></tr></tbody></table><h4 id="5-2-4-toString方法"><a href="#5-2-4-toString方法" class="headerlink" title="5.2.4 toString方法"></a>5.2.4 toString方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName()</span><br><span class="line">+<span class="string">&quot;[name=&quot;</span>+name</span><br><span class="line">+<span class="string">&quot;,salary=&quot;</span>+salary</span><br><span class="line">+<span class="string">&quot;,hireDay=&quot;</span>+hireDay</span><br><span class="line">+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==警告==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] luckNumbers=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br><span class="line">String s=<span class="string">&quot;&quot;</span>+luckNumbers;</span><br><span class="line"><span class="comment">// 生成”[I@1a46e30]“(前缀I标明是一个正i性能数组)</span></span><br><span class="line"><span class="comment">// 修正方法：</span></span><br><span class="line">String s=Arrays.toString(luckNumbers);</span><br><span class="line"><span class="comment">// 打印多维数组的方法：</span></span><br><span class="line">Arrays.deepToString();</span><br></pre></td></tr></table></figure><blockquote><p>==强烈建议==<br>为自定的类增加toString()方法。<br>java.lang.object 1.0<br>|方法|含义|<br>|–|–|<br>|Class getClass()|返回包含对象的类对象|<br>|boolean equals (Object otherObject)|比较两个对象是否相等，如果指向同一区域，则返回true|<br>|String toString()|返回描述对象值的字符串。在自定义的类中，应该覆盖这个方法|<br>java.lang.Class 1.0<br>|方法|含义|<br>|-|-|<br>|String getName()|返回这个类的名字|<br>|Class getSuperclass()|以Class对象的形式返回这个类的超类信息|</p></blockquote><h3 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h3><p>ArrayList是一个采用类型参数（type parameter）的泛型类（generic class）。</p><blockquote><p>如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始容量</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>一旦确定数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。<strong>确认不会添加任何元素时，再调用该方法</strong></p><h4 id="5-3-1-访问数组列表元素"><a href="#5-3-1-访问数组列表元素" class="headerlink" title="5.3.1 访问数组列表元素"></a>5.3.1 访问数组列表元素</h4><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>void set(int index,E obj)</td><td>设置数组列表指定位置的元素值，这个操作将覆盖这个位置的原有内容</td></tr><tr><td>E get(int index)</td><td>获得指定位置的元素值</td></tr><tr><td>void add(int index,E obj)</td><td>向后移动元素，以便插入元素</td></tr><tr><td>E remove(int index)</td><td>删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回</td></tr><tr><td>参数：index    __的元素位置（必须介于0~size()-1之间）</td><td></td></tr></tbody></table><h4 id="5-3-2-类型化与原始数组列表的兼容性"><a href="#5-3-2-类型化与原始数组列表的兼容性" class="headerlink" title="5.3.2 类型化与原始数组列表的兼容性"></a>5.3.2 类型化与原始数组列表的兼容性</h4><p>目前先跳过</p><h3 id="5-4-对象包装器与自动装箱"><a href="#5-4-对象包装器与自动装箱" class="headerlink" title="5.4 对象包装器与自动装箱"></a>5.4 对象包装器与自动装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">自动变换为</span><br><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br><span class="line">这种变换称为自动装箱(autoboxing)</span><br><span class="line">------------------------------</span><br><span class="line">相反的</span><br><span class="line"><span class="keyword">int</span> n=list.get(i);</span><br><span class="line"><span class="keyword">int</span> n=list.get(i).intValue();</span><br></pre></td></tr></table></figure><p>关于自动装箱还有几点说明：</p><ol><li>自动装箱可能会抛出一个NullPointerException 异常：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="number">2</span> * n);<span class="comment">// Throws NullPointerException</span></span><br></pre></td></tr></table></figure></li><li>如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升为double，再装箱为Double。<blockquote><p>拆箱和装箱是<strong>编译器</strong>认可的 ，而不是虚拟机。虚拟机只是执行这些字节码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成整形</span></span><br><span class="line"><span class="keyword">int</span> x=Integer.parseInt(s);</span><br><span class="line">与Integer对象没有任何关系，parseInt是一个静态方法。但Integer类是放置这个方法的一个好地方</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>int intValue</td><td>以int形式返回Integer对象的值</td></tr><tr><td>static String toString(int i)</td><td>以一个新String对象的形式返回给定数值i的十进制表示。</td></tr><tr><td>static intt paseInt(String s)</td><td></td></tr><tr><td>static int parseInt(String s,int radix)</td><td>返回字符串s表示的整型数值或radix参数进制的整数</td></tr><tr><td>static Integer valueOf(String s)</td><td></td></tr><tr><td>Static Integer value of(String s,int radix)</td><td>返回用s表示的整型数值进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数或radix参数进制的整数</td></tr><tr><td>Number parse(String s)</td><td>返回数字值，假设给定的String表示了一个数值</td></tr></tbody></table><h3 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h3>printf方法是这样定义的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String fmt,Object.... args)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> format(fmt,args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>printf方法接受两个参数，一个是格式字符串，另一个是Object[]数组，其中保存着所有的参数。</li></ol><p>跳过，需要补</p><hr><h3 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h3><p>跳过</p><h3 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h3><p>能够分析类能力的程序称为反射(reflective)。反射机制的功能极其强大，可以用来：</p><ul><li>在运行时分析类的能力</li><li>再运行时查看对象，例如，编写一个toString方法共所有类使用</li><li>实现通用的数组操作代码</li><li>利用Method对象，这个对象很想C++中的函数指针</li></ul><p>P190<br>to be continued…</p><h2 id="第6章-接口、lambda表达式与内部类"><a href="#第6章-接口、lambda表达式与内部类" class="headerlink" title="第6章 接口、lambda表达式与内部类"></a>第6章 接口、lambda表达式与内部类</h2><p>重点概念：</p><ol><li>接口</li><li>接口实例</li><li>lambda表达式</li><li>内部类</li><li>代理<h3 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h3>概念：<br>接口(interface)，这种技术主要用来描述类具有什么功能，而并不能给出每个功能的具体实现。<blockquote><p>一个类可以实现(implements)一个或多个接口，并再需要接口的地方，随时使用实现了相应接口的对象。</p></blockquote></li></ol><h4 id="6-1-1-接口的概念"><a href="#6-1-1-接口的概念" class="headerlink" title="6.1.1 接口的概念"></a>6.1.1 接口的概念</h4><p>接口不是类。<br>接口中的所有方法，自动的属于public。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y);</span><br><span class="line"><span class="number">1.</span>x&lt;y 负数  <span class="number">2.</span>x&gt;y 整数 <span class="number">3.</span>x=y 零</span><br></pre></td></tr></table></figure><p>==接口绝不能含有实例域。 ——接口没有实例==<br>可以将接口看成是没有实例域的抽象类。但是这两个概念还是有一定区别的。</p><p>类实现接口的步骤：</p><ol><li>将类声明为实现给定的接口。</li><li>对接口中的所有方法进行定义<br>要将类声明为实现某个接口，需要使用关键字implements：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br></pre></td></tr></table></figure><blockquote><p>在实现接口时，必须把方法声明为public，否则编译器将认为这个方法的访问属性时包可见性，即类的默认访问属性。</p></blockquote></li></ol><blockquote><p>提示：<br>Compareble接口中的compareTo方法有一点需要注意：整数的范围不能过大，以免造成减法运算的溢出。如果能够确信ID为非负整数，或者它们的绝对值不会超过(Integer.MAX_VALUE-1)/2,就不会出现问题。否则调用静态Integer.compare方法。<br><strong>该技巧不适用浮点值</strong></p></blockquote><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>int compareTo(T other)</td><td>用这个对象与other进行比较。如果这个对象小于other则返回复制；如果相等则返回0，否则返回正值</td></tr><tr><td>static void srot(Object[] a)</td><td>使用mergesort算法对数组a中的元素进行排序。要求数组中的元素必须属于实现了Comparable接口的类，并且元素之间必须是可比较的。</td></tr><tr><td>static int compare(int x,int y)</td><td>如果x&lt;y返回一个负整数；如果x和y相等，则返回0；否则返回一个负整值</td></tr><tr><td>static int compare(double x,double y)</td><td>同上</td></tr></tbody></table><blockquote><p>如果x是一个Employee对象，y是一个Manager对象，调用x.compare(y)不会抛出异常，它只是将x和y都作为雇员进行比较。但是反过来，y.compare(x)将会抛出一个ClassCastException。<br><strong>解决：</strong><br>如果存在这样一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个compareTo方法，并将这个方法声明为final。</p></blockquote><h4 id="6-1-2-接口的特性"><a href="#6-1-2-接口的特性" class="headerlink" title="6.1.2 接口的特性"></a>6.1.2 接口的特性</h4><blockquote><p>不能构造接口的对象，却能声明接口的变量。<br>接口变量必须引用实现了接口的类对象：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparable x;<span class="comment">//ok</span></span><br><span class="line">x=<span class="keyword">new</span> Employee(···);<span class="comment">// ok provided Employee implements Comparable</span></span><br></pre></td></tr></table></figure><blockquote><p>可以用instanceof检查一个对象是否实现了某个特定的几口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> Comparable)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中不饿能包含实例域或静态方法，但可以包含常量。**接口中的域自动被设为public static final</p></blockquote><p>Cloneable接口可以使自己设计的列具有克隆和比较的能力。6.2.3 详细讨论</p><h4 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h4><p>Java不允许多重继承。</p><h4 id="6-1-4-静态方法"><a href="#6-1-4-静态方法" class="headerlink" title="6.1.4 静态方法"></a>6.1.4 静态方法</h4><p>允许在接口中加静态方法，但没必要。（有违将接口作为抽象规范的初衷）</p><h4 id="6-1-5-默认方法"><a href="#6-1-5-默认方法" class="headerlink" title="6.1.5 默认方法"></a>6.1.5 默认方法</h4><p>default 不太明白。 伴随类。。。</p><h4 id="6-1-6-解决默认方法冲突"><a href="#6-1-6-解决默认方法冲突" class="headerlink" title="6.1.6 解决默认方法冲突"></a>6.1.6 解决默认方法冲突</h4><ol><li>超类优先。如果超类提供了一个具体方法，同名而且具有相同参数类型的默认方法会被忽略</li><li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须发改这个方法来解决冲突。</li></ol><blockquote><p>如果：一个类拓展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。<br><strong>这种情况下只考虑超类方法，接口的所有默认方法都会被忽略。</strong><br>这正是<strong>类优先规则</strong></p></blockquote><p>==前往不要让一个默认方法重新定义Object类中的某个方法==</p><h3 id="6-2-接口实例"><a href="#6-2-接口实例" class="headerlink" title="6.2 接口实例"></a>6.2 接口实例</h3><h4 id="6-2-1-接口与回调"><a href="#6-2-1-接口与回调" class="headerlink" title="6.2.1 接口与回调"></a>6.2.1 接口与回调</h4><p>回调(callback)是一种常见的程序设计模式。这个模式中，可以指定某个特定事件发生时应该采取的动作。</p><p>每十秒打印一条信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;At the tone,the time is &quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-2Comparator接口"><a href="#6-2-2Comparator接口" class="headerlink" title="6.2.2Comparator接口"></a>6.2.2Comparator接口</h4><p> 类似comparable</p><h4 id="6-2-3-对象克隆"><a href="#6-2-3-对象克隆" class="headerlink" title="6.2.3 对象克隆"></a>6.2.3 对象克隆</h4><p> 不常见。后续补充把<br> 流程图待补充</p><h3 id="6-3-lambda表达式"><a href="#6-3-lambda表达式" class="headerlink" title="6.3 lambda表达式"></a>6.3 lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second)</span><br><span class="line">-&gt;first.length()-second.length()</span><br></pre></td></tr></table></figure><p>这就是你看到的第一个<em>lambda</em>表达式。lambda表达式就是一个代码块，以及必须传入代码的变量规范。<br>如果代码要完成的计算无法放在一个表达式中，就可以想写方法一样，把这些代码放在{ }中，并包含显示的return语句。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second)-&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(first.length()&lt;second.length() <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3-函数式接口"><a href="#6-3-3-函数式接口" class="headerlink" title="6.3.3 函数式接口"></a>6.3.3 函数式接口</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口(functional interface)。</p><blockquote><p>接口可以声明非抽象方法</p></blockquote><p>展示如何转换为函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,</span><br><span class="line">(first,second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><p>在底层，Arrays.sort方法会接受实现了Comparator&lt; String &gt;的某个类的对象。在这个对象上调用compare方法会执行这个lambada表达式的体。这些对象和类的管理完全取决于具体实现，与使用传统的内联类相比，这样可能要高效的多。</p><p>lambda表达式可以转换为接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Timer t&#x3D;new Timer(1000,event -&gt; </span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;At the tone,the time is&quot;+new Date());</span><br><span class="line">Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>lambda表达式所能做的也只是能转换为函数式接口。</strong></p><p>ArrayList类有一个removeIf方法，它的参数就是Predicate。这个接口专门用来传递lambda表达式。例如，从一个数组列表删除所有null值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeIf(e -&gt; e==<span class="keyword">null</span>;);</span><br></pre></td></tr></table></figure><h4 id="6-3-4-方法引用"><a href="#6-3-4-方法引用" class="headerlink" title="6.3.4 方法引用"></a>6.3.4 方法引用</h4><p>只要出现定时器就打印这个事件对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Timer t=<span class="keyword">new</span> Timer(<span class="number">1000</span>,event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">// 但是将println方法传到构造器就更好了</span></span><br><span class="line">Timer t=<span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</span><br><span class="line"><span class="comment">// 表达式sout是一个方法引用(method reference),等价于lambda表达式</span></span><br><span class="line"><span class="comment">// --&gt; </span></span><br><span class="line">x-&gt;System.out.println(x);</span><br></pre></td></tr></table></figure><p>要用 :: 操作符分隔方法名与对象或类名。主要有3种情况：</p><ul><li>object::instanceMethod</li><li>Class::staticMethod</li><li>Class::instanceMethod</li></ul><p>前两种情况，方法引用等价于提供方法参数的lambda表达式。前面已经提到，System.out::println等价于x-&gt;System.out.println(x)。类似的Math::pow等价于(x,y)-&gt;Math.pow(x,y)。</p><p>对于第三种情况，第一个参数会成为方法的目标。例如，String::compareToIgnoreCase等同于(x,y) -&gt; x.compareToIgnoreCase(y)。</p><ol><li>可以在方法引用种使用this参数</li><li>使用super也是合法的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>::equals x-&gt;<span class="keyword">this</span>.equals(x)；</span><br><span class="line"><span class="keyword">super</span>::instanceMethod</span><br></pre></td></tr></table></figure></li></ol><p>super 例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimedGreeter</span> <span class="keyword">extends</span> <span class="title">Greeter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Timer t=<span class="keyword">new</span> Timer(<span class="number">1000</span>,<span class="keyword">super</span>::greet);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会调用超类的greet方法。</p><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><p>没看懂  先掠过</p><h4 id="6-4-6-变量作用域"><a href="#6-4-6-变量作用域" class="headerlink" title="6.4.6 变量作用域"></a>6.4.6 变量作用域</h4><p>lambda表达式有三个部分：</p><ol><li>一个代码块；</li><li>参数</li><li>自由变量的值，这里指非参数而且不在代码中定义的变量。</li></ol><blockquote><p>在lambda表达式中引用变量，有一个重要的限制。<strong>只能引用不会改变的变量</strong>。<br>如果在lambda中改变变量，并发执行多个动作时不安全 –》 14章详解</p></blockquote><p>如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String text,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ActionListener listener =event -&gt;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i+<span class="string">&quot;:&quot;</span>+text);</span><br><span class="line"><span class="comment">// error: cannot refer to changing</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Timer(<span class="number">1000</span>,listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一条规则：lambda表达式捕获的变量必须实际上是最终变量(effectively final)。</p><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Application</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ActionListener listener=event-&gt;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Application对象的toString方法。</p><h4 id="6-3-7-处理lambda表达式"><a href="#6-3-7-处理lambda表达式" class="headerlink" title="6.3.7 处理lambda表达式"></a>6.3.7 处理lambda表达式</h4><p>太难了…<br>使用lambda表达式的重点是延迟执行(deferred execution)。之所以希望以后再执行有很多原因，如：</p><ul><li>在一个单独的线程中运行代码</li><li>多次运行代码</li><li>在算法的适当位置运行代码（例如，排序中的比较操作符）；</li><li>发生某种情况时执行代码（如，点击了一个按钮，数据到达，等等）；</li><li>只在必要时才运行代码</li></ul><p>想要重复一个动作n次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">10</span>,()-&gt;System.out.println(<span class="string">&quot;Hello,World!&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="6-3-8-再谈Comparator"><a href="#6-3-8-再谈Comparator" class="headerlink" title="6.3.8 再谈Comparator"></a>6.3.8 再谈Comparator</h4><p>后续再看一遍lambda吧</p><h3 id="6-4-内部类"><a href="#6-4-内部类" class="headerlink" title="6.4 内部类"></a>6.4 内部类</h3><p>**内部类(inner class)**是定义在另一个类中的类。为什么需要使用内部类。主要原因有三点：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用**匿名(anonymous)**内部类比较便捷。<h4 id="6-4-1-使用内部类访问对象状态"><a href="#6-4-1-使用内部类访问对象状态" class="headerlink" title="6.4.1 使用内部类访问对象状态"></a>6.4.1 使用内部类访问对象状态</h4><blockquote><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p></blockquote></li></ul><h4 id="6-4-2-内部类的特殊语法规则"><a href="#6-4-2-内部类的特殊语法规则" class="headerlink" title="6.4.2 内部类的特殊语法规则"></a>6.4.2 内部类的特殊语法规则</h4><p>外围类引用的语法，表达式</p><blockquote><p>outerClass.this</p></blockquote><p>如果TimePrinter是一个公有内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TalkingClock jabberer=<span class="keyword">new</span> TalkingClock(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line">TalkingClock.TimerPrinter listener = jabberer.<span class="function">new <span class="title">TimerPrinter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意：<br>在外围类的作用域之外，可以这样引用内部类<br>Outer.InnerClass</p><h4 id="6-4-3-内部类是否有用、必要和安全"><a href="#6-4-3-内部类是否有用、必要和安全" class="headerlink" title="6.4.3 内部类是否有用、必要和安全"></a>6.4.3 内部类是否有用、必要和安全</h4><p>不懂</p><h4 id="6-4-4-局部内部类"><a href="#6-4-4-局部内部类" class="headerlink" title="6.4.4 局部内部类"></a>6.4.4 局部内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerPrinter</span> <span class="keyword">implements</span> <span class="title">ActionLIstener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;At the tone,the time is &quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">if</span>(beep)Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ActionListener listener =<span class="keyword">new</span> TimePrinter();</span><br><span class="line">Timer t=<span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>局部类不能用public或private修饰符进行声明。他的作用域被限制在这个局部类的代码块中。<br>局部类有一个优势，即对外部世界可以完全隐藏。即使TalkingClock中的其他代码也不能访问它。除了start方法之外，没有任何方法知道它的存在。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二章-程序设计环境&quot;&gt;&lt;a href=&quot;#第二章-程序设计环境&quot; class=&quot;headerlink&quot; title=&quot;第二章 程序设计环境&quot;&gt;&lt;/a&gt;第二章 程序设计环境&lt;/h2&gt;&lt;h3 id=&quot;2-1-安装Java开发工具包&quot;&gt;&lt;a href=&quot;#2-1-安装</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>高数</title>
    <link href="http://example.com/2021/04/29/%E9%AB%98%E6%95%B0/"/>
    <id>http://example.com/2021/04/29/%E9%AB%98%E6%95%B0/</id>
    <published>2021-04-29T08:09:41.000Z</published>
    <updated>2021-04-29T12:52:36.947Z</updated>
    
    <content type="html"><![CDATA[<img src="https://uploader.shimo.im/f/KA4ZlZ8XHcy633sA.png!thumbnail" align="center"><h2 id="一章-函数与极限"><a href="#一章-函数与极限" class="headerlink" title="一章 函数与极限"></a>一章 函数与极限</h2><p><strong>数形结合的思想</strong><br><font style="color:hotpink;font-size:1.5rem;text-shadow:3px 3px 30px d79a8">数无形时少直观，形少数时难入微</font> </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>y=f(x)</p><p>x=自变量 定义域</p><p>y=因变量 值域</p><p>f=对应法则对变量的约束</p><ul><li>运算的约束  </li><li>范围的约束 </li></ul><h4 id="基本初等函数"><a href="#基本初等函数" class="headerlink" title="基本初等函数"></a>基本初等函数</h4><p><font style="color:red;font-size:1.5rem">初等函数在其定义域内都是连续可导的【不需证明】）</font></p><p>反  对  幂  三  指 </p><h4 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h4><blockquote><p>是由基本初等函数经过四则或复合运算形成一个表达式的函数单调性，是在定义域内，是增还是减。 连续的函数才有单调性例: y=x^2 无单调性（需看图像）</p></blockquote><p>$$<br>1.a^m*a^n=a^{m+n},2.(a^m)^n=a^{mn},3\frac{a^m}{a^n}=a^{m-n}<br>$$</p><h4 id="对数运算发则"><a href="#对数运算发则" class="headerlink" title="对数运算发则"></a>对数运算发则</h4><p><img src="https://uploader.shimo.im/f/SMwbx5j49buhYaaf.png!thumbnail" alt="img"> </p><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><ul><li><p>y=sinx </p><ul><li>定义域 ①x∈R ②-1≤sinx≤1（有界函数）  </li><li>周期性$$T=2\pi$$.</li><li>奇函数 （关于原点对称，奇函数）</li><li>关于原点，旋转 180° 重合 </li><li>三边关系 对/斜</li></ul></li><li><p>y=cosx </p><ul><li>定义域 ①x∈R ②-1≤cosx≤1（有界函数）  </li><li>周期性 T=2Π  偶函数（关于 Y 轴对称）  </li><li>三边关系 邻/斜 </li></ul></li><li><p>y=tanx 定义域 x≠kΠ+Π/2（不是有界函数）  </p><ul><li><p>周期 T=Π  </p></li><li><p>奇函数  </p></li><li><p>增函数  </p></li><li><p>三边关系 对/邻 </p></li></ul></li><li><p>y=cotx=cosx/sinx </p><ul><li><p>定义域 x≠kΠ  </p></li><li><p>奇函数  </p></li><li><p>周期 T=Π </p></li><li><p>由 tanx 先对称，再平移Π/2  </p></li><li><p>y=secx=1/cosx  </p></li><li><p>y=cscx=1/sinx </p></li></ul></li></ul><p><img src="https://uploader.shimo.im/f/QJicxBbkCD7MHeO8.png!thumbnail" alt="img"></p><h3 id="定义域"><a href="#定义域" class="headerlink" title="定义域"></a>定义域</h3><ul><li><p>根号下</p><ul><li>定义域：≥ 0</li></ul></li><li><p>对数（lnx）定义域：</p><ul><li>是分母 ≠1 &amp;  &gt; 0  </li><li>不是分母 ＞0 </li></ul></li><li><p>抽象函数的定义域</p></li></ul><p>已知简单求复杂（复合） </p><ul><li><p>定义域特指 x 的范围</p></li><li><p>f 法则实质就是对自变量的约束（范围、运算）同一个 f 就有同样的约束效果</p></li></ul><p>f(x)的定义域为（0,1），求 f(x+1)的定义域</p><p>解析：因为两项的对应法则（对自变量的约束都是 f）相同，所以 x+1 的定义域与 x 相同→ 0&lt;x+1&lt;1  → -1&lt;x&lt;0</p><p>已知复合函数</p><h3 id="无穷大量-amp-无穷小量"><a href="#无穷大量-amp-无穷小量" class="headerlink" title="无穷大量&amp;无穷小量"></a>无穷大量&amp;无穷小量</h3><p>无穷小×有界=无穷小  </p><p>c/0 = ∞</p><p>1/∞ = 0</p><p>什么时候分左右极限 </p><p>当 1/x 在 x→∞时  </p><p>当 1/x 在 x→0时  </p><p>当 arctanx 在 x→∞时  </p><p>当 e^x 在 x→∞时 </p><h3 id="未定式"><a href="#未定式" class="headerlink" title="未定式"></a>未定式</h3><p>∞/∞型、0/0型、∞±∞型、1^∞型、0*∞型 </p><ul><li><p>∞/∞ 1.取大 2.取大（整体最大，去常数）消小 洛必达  </p></li><li><p>± 有分母通分，没分母有理化  </p></li><li><p>0/0 &amp; ∞/∞ 洛必达 有理化 </p></li></ul><h3 id="连续和间断点"><a href="#连续和间断点" class="headerlink" title="连续和间断点"></a>连续和间断点</h3><p>连续：</p><p>满足连续的条件 </p><blockquote><p> 函数在定义域内是连续的。函数图像一笔不间断的画下来（<font style="color:rgb(52,152,219);font-size:1.5rem">一笔画</font> ）函数在某一点 x0 处是连续的</p></blockquote><ul><li><p>f(x0)要存在 </p></li><li><p>左极限＝右极限=在 x0 的函数值 </p></li></ul><p>分段函数连续=&gt;分段函数在分段点处 x0 也连续</p><h3 id="间断点："><a href="#间断点：" class="headerlink" title="间断点："></a>间断点：</h3><p>定义：</p><blockquote><p>设一元实函数 f（x）在点 x0 的某去心邻域内有定义。                                                                </p><p>如果函数 f(x)有下列情形之一：</p><p>（1）函数 f(x)在点 x0 的左右极限都存在但不相等，即 f(x0+)≠f(x0-)；                                               </p><p>（2）函数f(x)在点x0的左右极限中至少有一个不存在；</p><p>（3）函数f(x)在点x0的左右极限都存在且相等，但不等于f(x0)或者f(x)在点x0无定义。</p><p>则函数 f(x)在点 x0 为不连续，而点 x0 称为函数 f(x)的间断点。</p></blockquote><h4 id="第一类间断点"><a href="#第一类间断点" class="headerlink" title="第一类间断点"></a>第一类间断点</h4><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">可去间断点</span> </p><ul><li><p>情况</p><ul><li><p> ①x处左右极限都存在，但在x处无定义  </p></li><li><p>②左右极限都存在，且x处也有定义，但不相等 </p></li></ul></li></ul><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">跳跃间断点</span> </p><ul><li>情况<ul><li>①左右极限都存在，但不相等 </li></ul></li></ul><h4 id="第二类间断点"><a href="#第二类间断点" class="headerlink" title="第二类间断点"></a>第二类间断点</h4><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">震荡间断点</span> </p><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">无穷间断点</span> ：x处的左右极限至少一个为∞</p><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><h4 id="极限存在的三个充要条件："><a href="#极限存在的三个充要条件：" class="headerlink" title="极限存在的三个充要条件："></a>极限存在的三个充要条件：</h4><ol><li>左极限存在  </li><li>右极限存在  </li><li>左右极限相等 </li></ol><h4 id="求极限："><a href="#求极限：" class="headerlink" title="求极限："></a>求极限：</h4><p>$$\lim_{x\to0}$$.</p><ul><li>等价无穷小</li></ul><p>$$\lim_{x\to ∞}$$.：</p><ul><li><p>1/∞ = 0  </p></li><li><p>∞/1 = ∞ </p></li></ul><h4 id="无穷小："><a href="#无穷小：" class="headerlink" title="无穷小："></a>无穷小：</h4><ul><li><p>高阶无穷小</p><ul><li>β/α=0 β是α的高阶无穷小</li></ul></li><li><p>同阶无穷小</p><ul><li>β/α=C（C≠1）</li></ul></li><li><p>等价无穷小：</p><ul><li>β/α=1 </li></ul></li></ul><p>sinx ~ x ~ arcsinx  </p><p>e^x → e^x </p><p>无穷小公式表 待插入 </p><p>低阶无穷小 </p><h4 id="两个重要极限"><a href="#两个重要极限" class="headerlink" title="两个重要极限"></a>两个重要极限</h4><ol><li>①1后面加无穷小量②这个无穷小量与指数互为倒数（双倒数法）</li><li>①1是实实在在的1（+1，-1法）②第二类重要极限和x的趋近方式没有任何关系 </li></ol><h4 id="三角函数图像"><a href="#三角函数图像" class="headerlink" title="三角函数图像"></a>三角函数图像</h4><p>arcsinx &amp; sinx</p><p><img src="https://uploader.shimo.im/f/hBoUBbH7DBkasyUw.jpg!thumbnail" alt="img"><br>   arctanx<br>   <img src="https://uploader.shimo.im/f/7Tf6NlfANJERu9hS.jpg!thumbnail" alt="img"><br>   arccosx<br>   <img src="https://uploader.shimo.im/f/PnIV9jWaZE71T1M5.jpg!thumbnail" alt="img"></p><h3 id="三角函数公式"><a href="#三角函数公式" class="headerlink" title="三角函数公式"></a>三角函数公式</h3><p><img src="https://uploader.shimo.im/f/itrrigGv81ADW8ae.png!thumbnail" alt="img"><br><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">1.对角线倒数</span><br>$$<br>sinx=\frac{1}{cscx}<br>$$<br><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">2.倒三角平方和</span><br>$$<br>sin^2x+cos^2x=1,tan^2x+1=sec^2x,1+cot^2x=csc^2x<br>$$</p><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">3.邻点积</span><br>$$<br>sinx=tanx*cosx<br>$$</p><h4 id="三角函数导数公式"><a href="#三角函数导数公式" class="headerlink" title="三角函数导数公式"></a>三角函数导数公式</h4><blockquote><p>注：发”co”音的三角函数求导为负</p><p>cos cot csc</p></blockquote><p>上互换</p><ul><li>$sinx’=cosx cosx=-sinx$</li></ul><p>中下方（中顶点的导数=下顶点的平方）</p><ul><li>$tanx’=secx^2$</li></ul><p>下中下（下顶点的导数=中顶点*下顶点）</p><ul><li>$secx’=tanx*secx $</li></ul><h4 id="二倍角公式（降幂公式）"><a href="#二倍角公式（降幂公式）" class="headerlink" title="二倍角公式（降幂公式）"></a>二倍角公式（降幂公式）</h4><p>$$<br>cos2\alpha=cos^2\alpha-sin^2\alpha  =2cos^2\alpha-1 \Rightarrow cos^2\alpha=\frac{1+cos^2\alpha}{2}   =1-2sin^2\alpha \Rightarrow sin^2\alpha=\frac{1-cos^2\alpha}{2}<br>$$</p><h2 id="二章-导数与微分"><a href="#二章-导数与微分" class="headerlink" title="二章 导数与微分"></a>二章 导数与微分</h2><p><img src="https://uploader.shimo.im/f/VVBmI5Za3Xwa6ggi.png!thumbnail" alt="img"><br><img src="https://uploader.shimo.im/f/4JPzOIS6w7WJWlCX.png!thumbnail" alt="img"></p><h3 id="导数的概念"><a href="#导数的概念" class="headerlink" title="导数的概念"></a>导数的概念</h3><p>瞬时的平均量</p><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p>第一定义<br>$$<br>f’(x_0) = lim_{\Delta{x}-&gt;0} \frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}<br>$$<br>令 $$x_0+\Delta x=x$$，导数第二定义式为 ：<br>$$<br>f’(x_0)=lim_{x-&gt;x_0} \frac{f(x)-f(x_0)}{x-x_0}<br>$$<br>⭐导数存在的充要条件：</p><ul><li>f’(x0)存在，且等于左导=右导</li></ul><h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><h4 id="题型一：配导数定义"><a href="#题型一：配导数定义" class="headerlink" title="题型一：配导数定义"></a>题型一：配导数定义</h4><p>法一</p><ul><li>配导数第一定义</li></ul><p>法二</p><ul><li>“去 f 法”对所求极限，去”f”去”lim”后结果是几，所求极限就是几倍的已知导数</li></ul><h4 id="题型二：分段函数在分段点处的可导性"><a href="#题型二：分段函数在分段点处的可导性" class="headerlink" title="题型二：分段函数在分段点处的可导性"></a>题型二：分段函数在分段点处的可导性</h4><p>导数第二定义，求左右极限。将对应的分段函数式代入并化简</p><p>比较左右极限与导数的值是否相等<br><img src="https://uploader.shimo.im/f/VCbDu7J8txJSAe1G.png!thumbnail" alt="img"> </p><h3 id="导数的几何意义"><a href="#导数的几何意义" class="headerlink" title="导数的几何意义"></a>导数的几何意义</h3><p>初中求切线，点斜式(k 就是斜率)<br>$$<br>y-y_0=k(x-x_0)，k=tan\alpha（ankle）<br>$$</p><h4 id="切线"><a href="#切线" class="headerlink" title="切线"></a>切线</h4><p>切线公式<br>$$<br>y-y_0=f’(x_0)(x-x_0)<br>$$<br>①切点为（x0,y0)②斜率f’(x0)=tanα</p><h4 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h4><p>概念：过切点且垂直于切线，垂直的两条线，斜率相乘=-1<br>$$<br>k_切*k_法=-1，k_法=\frac{1}{k_切}<br>$$<br>法线公式<br>$$<br>y-y_0=-\frac{1}{f’(x_0)}(x-x_0)<br>$$<br>两直线平行，斜率相等。<br>###　导数与导函数</p><ol><li>导函数的本质是一个函数，即 f(x)，导数的本质是个数，即 f’(x0)  </li><li>导数是导函数具体点处的函数值  </li></ol><blockquote><p>x 是未知数，所以 f(x)是导函数，x0 是常数，所以 f(x0)是导数</p></blockquote><h3 id="导数公式"><a href="#导数公式" class="headerlink" title="导数公式"></a>导数公式</h3><p><img src="https://uploader.shimo.im/f/STlqZAkCpfj9VTVX.jpg!thumbnail" alt="img"> </p><h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><p>四则运算法则</p><ul><li>和/差的导=导的和差</li></ul><p>$$<br>(u±v)’=u’±v’<br>$$</p><ul><li>常数可以直接提出去，先对函数进行导数运算 </li><li>前导后不导+前不导后导</li></ul><p>$$<br>(uv)’=u’v+uv’,(uvw)’=u’vw+uv’w+uvw’<br>$$</p><ul><li>u 比 v 导</li></ul><p>$$<br>(\frac{u}{v})’=\frac{u’v-uv’}{v^2}<br>$$</p><h4 id="复合运算"><a href="#复合运算" class="headerlink" title="复合运算"></a>复合运算</h4><ul><li>链式法则</li></ul><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><p>y 中有 x，x 中有 y。</p><p>解法：</p><p>先对 y 求导，再乘 一个 y’。</p><p><del>参数方程</del></p><p><del>微分</del></p><p><del>求近似值</del></p><h4 id="微分在近似计算中的应用"><a href="#微分在近似计算中的应用" class="headerlink" title="微分在近似计算中的应用"></a>微分在近似计算中的应用</h4><p>$$<br>\Delta{y}≈dy=f’(x_0)\Delta{x}<br>$$<br>dy≈$$\Delta$$y，dx=$$\Delta$$x</p><p>$$\Delta y=f(x_0+\Delta x)-f(x_0)$$.<br>推导出<br>$$<br>f(x_0+\Delta{x})-f(x_0)≈y’(x_0)\Delta{x})<br>$$<br>推导出<br>$$<br>f(x_0+\Delta{x})≈f(x_0)+f’(x_0)\Delta{x}<br>$$</p><h3 id="题型-1"><a href="#题型-1" class="headerlink" title="题型"></a>题型</h3><ul><li>求曲线上一点的切线/法线方程 <ul><li>将切点$(x_0,y_0)$代入  </li><li>求斜率 f’(x0)  </li><li>化简即可  </li></ul></li><li>求过曲线外一点的切线方程  </li><li>俩曲线 <h2 id="三章-微分中值定理与导数应用"><a href="#三章-微分中值定理与导数应用" class="headerlink" title="三章 微分中值定理与导数应用"></a>三章 微分中值定理与导数应用</h2></li></ul><h3 id="一节-微分中值定理"><a href="#一节-微分中值定理" class="headerlink" title="一节 微分中值定理"></a>一节 微分中值定理</h3><p>一、罗尔定理</p><p>f(x)</p><ol><li>[a,b]连续  </li><li>(a,b)连续  </li><li>f(a)=f(b)（端点值相等）</li></ol><p> =&gt;至少有一点∮∈(a,b) 使f’(∮)=0</p><h3 id="四节-函数的单调性与区间的凹凸性"><a href="#四节-函数的单调性与区间的凹凸性" class="headerlink" title="四节 函数的单调性与区间的凹凸性"></a>四节 函数的单调性与区间的凹凸性</h3><h4 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h4><p>定义：</p><ul><li>增函数</li></ul><p>$$<br>y=f(x)↑:x_2&gt;x_1=&gt;f(x_2)&gt;f(x_1)<br>$$</p><ul><li>减函数</li></ul><p>$$<br>y=f(x)↓:x_2&gt;x_1=&gt;f(x_2)<br>$$</p><ul><li>判断：</li></ul><p>$$<br>f’(x)&gt;0=&gt;y=f(x)↑  f’(x)&lt;0=&gt;y=f(x)↓<br>$$<br>驻点： </p><p>f’(x)=0(一阶导=0 的点）</p><h4 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h4><ol><li>判断凹凸性</li></ol><ul><li><p>y’’&gt;0 =&gt; y=f(x) 为凹</p></li><li><p>y’’&lt;0 =&gt; y=f(x) 为凸</p></li></ul><ol start="2"><li>拐点</li></ol><ul><li>曲线 y=f(x)的凹凸分界点</li></ul><ol start="3"><li>判断凹凸性及拐点</li></ol><h3 id="函数的极值与最值"><a href="#函数的极值与最值" class="headerlink" title="函数的极值与最值"></a>函数的极值与最值</h3><h4 id="极值"><a href="#极值" class="headerlink" title="极值"></a>极值</h4><ol><li><p>定义：</p></li><li><p>判断：</p></li></ol><ul><li><p>可能极值点</p><ul><li>y’(x)=0的点（驻点）</li><li>y’(x)不可导点下                     </li></ul></li><li><p>可能最值点</p><ul><li>极值点</li><li>区间端点</li></ul></li><li><p>极值是局部的最大最小值</p><ul><li>极大值&gt; 极小值 <font style="color:red;font-size:1.5rem">×</font> <span style="background:rgb(231,76,60);color:white;padding:5px">（不一定，极大值极小值是一个局部概念【邻域】）</span> </li><li>最大值 &gt; 最小值 <font style="color:green;font-size:1.5rem">√ </font> <span style="background:green;color:white;padding:5px"> （最值是整体概念，整个定义域内最大或最小的）</span></li></ul></li></ul><p>例题：</p><p>大值一定大于最小值  <font style="color:green;font-size:1.5rem">√</font> </p><p>驻点一定是极值点 <font style="color:red;font-size:1.5rem">×</font> </p><p>可导函数的极值点一定是驻点 <font style="color:green;font-size:1.5rem">√</font>  <font style="color:rgb(189,195,199);font-size:1.1rem">（可导函数就不存在不可导点）</font> </p><p>驻点两侧f’(x)异号，则该驻点是极值点 <font style="color:green;font-size:1.5rem">√</font> </p><ol start="3"><li>求极值（抓小偷问题）</li></ol><ul><li><p>找可能极值点</p><ul><li>f’(x)=0的点（驻点）</li><li>f’(x)不存在（尖点）</li></ul></li><li><p>判断可能极值点是否为极值点</p><ul><li>法一：只适用可能极值点中的驻点<ul><li><span style="border:3px solid lightblue">二阶导非0的驻点，一定是极值点</span> </li></ul></li></ul></li></ul><p><img src="https://uploader.shimo.im/f/D73Hg4j58MgQjVq9.png!thumbnail" alt="img"></p><ul><li><ul><li>法二：适用于所有可能极值点</li></ul></li></ul><p><img src="https://uploader.shimo.im/f/1oVxGKgzdHPq8IbN.png!thumbnail" alt="img"></p><h3 id="题型-2"><a href="#题型-2" class="headerlink" title="题型"></a>题型</h3><p>注：单调区间有两个，不用’<font style="color:red;font-size:1.5rem">∪</font> ‘，而用’<font style="color:red;font-size:1.5rem">,</font> ‘</p><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">求单调区间的步骤 </span> </p><ol><li>求定义域  </li><li>求出全部驻点（一阶导=0 的点）和一阶导不存的点 =&gt;<strong>可能极值点</strong> </li><li>用所有可能极值点划分定义域成若干个小区间  </li><li>判断子区间上 f’(x)的符号</li></ol><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">求拐点[x0,f(x0)]步骤</span> </p><ol><li>求可能拐点</li></ol><ul><li><p>y’’(x)=0的点</p></li><li><p>y’’(x)不存在的点</p></li></ul><ol start="2"><li>判断可能的拐点是否为拐点</li></ol><ul><li>看可能拐点x0两侧y’’(x)是否异号，若异号即为拐点 </li></ul><blockquote><p>注：</p><p>①二阶可导函数的拐点一定是二阶导等于零的点</p><p>②拐点可能是二阶导等于零的点，也可能是二阶导不存在的点</p></blockquote><p><img src="https://uploader.shimo.im/f/3uvA1H7L334nkicY.png!thumbnail" alt="img"></p><h2 id="第四章-不定积分"><a href="#第四章-不定积分" class="headerlink" title="第四章 不定积分"></a>第四章 不定积分</h2><h3 id="一节-不定积分的概念"><a href="#一节-不定积分的概念" class="headerlink" title="一节 不定积分的概念"></a>一节 不定积分的概念</h3><ul><li>原函数与不定积分的概念：<ul><li>原函数：若F’(x)=f(x)=&gt;<ul><li>f(x)是F(x)的<FONT STYLE="COLOR:RED;FONT-SIZE:1.5REM">导</FONT> 函数 </li><li>F(x)是f(x)的<font style="color:purple;font-size:1.5rem">原</font> 函数</li></ul></li></ul></li></ul><blockquote><p>注：</p><p>若f(x）有一个原函数F(x)，则f(x)有无数个原函数为F(x)+C，C为任意常数 </p></blockquote><ul><li><p>不定积分：找f(x)所有原函数的过程就就称为对f(x）</p></li><li><p><span style="border-bottom:2px solid rgb(52,152,219);background:rgb(236,240,241)">求不定积分基本积分公式</span> </p></li></ul><p><img src="https://uploader.shimo.im/f/HL5Rnyo73TQAxffj.jpg!thumbnail" alt="img"> </p><ul><li>运算性质</li></ul><p>$$<br>∫[f(x)±g(x)]dx=∫f(x)dx±g(x)dx<br>$$</p><p>$$<br>∫kf(x)dx=kf(x)dx<br>$$</p><p>==注：没有乘除的性质==</p><ul><li>∫ f(x)dx=F(x)+C<ul><li>【被积函数【x为函数变量】】 </li><li>【积分变量】</li><li>【一个原函数+积分常量=&gt; 全部原函数】</li></ul></li></ul><p><font style="color:hotpink;font-size:1.5rem">函数变量与积分变量必须一致</font> </p><h3 id="二节-换元积分"><a href="#二节-换元积分" class="headerlink" title="二节 换元积分"></a>二节 换元积分</h3><h4 id="第一类换元积分"><a href="#第一类换元积分" class="headerlink" title="第一类换元积分"></a>第一类换元积分</h4><ul><li>配凑法：</li></ul><ol><li>凑狗（凑微分，第一类换元法）</li></ol><ul><li>理论依据</li></ul><p>$$<br>dy(x)=y’(x)dx<br>$$</p><ol start="2"><li>第二步</li></ol><ul><li>①被积函数中的<font style="color:rgb(190,98,38);font-size:1.5rem"> 求导项整体不动</font>，<font style="color:rgb(231,182,42);font-size:1.5rem">比较项不要</font> ，然后<font style="color:red;font-size:1.5rem">求导项放d后</font> （3个操作）</li><li>凑微分的过程中注意==系数==的配置</li></ul><p><img src="https://uploader.shimo.im/f/7DtlV4LT4PQNikua.png!thumbnail" alt="img"></p><h4 id="题型："><a href="#题型：" class="headerlink" title="题型："></a>题型：</h4><p>列项公式</p><ul><li>条件<ul><li>平方差公式</li><li>二次三项式</li></ul></li></ul><p><img src="https://uploader.shimo.im/f/JxcpdNFyYZB61TTO.png!thumbnail" alt="img"><br>$$<br>\frac{A}{(x+a)(x+b)}=\frac{1}{b-a}(\frac{1}{x+a}-\frac{1}{x+b})<br>$$</p><ul><li>arcsinx</li></ul><p>$$<br>\int\frac{1}{\sqrt{1-x^2}}dx=arcsinx+c \Rightarrow\int\frac{1}{\sqrt{a^2-x^2}}dx=arcsin\frac{x}{a}+c<br>$$</p><ul><li>arctanx</li></ul><p>$$<br>\int\frac{1}{1+x^2}dx=arctanx+c \Rightarrow\int\frac{1}{\sqrt{a^2+x^2}}dx=\frac{1}{a}arctan\frac{x}{a}+c<br>$$</p><ul><li>lnx</li></ul><p>$$<br>\int\frac{1}{x^2-a^2}dx=\frac{1}{2a}[ln\left |x-a \right|-ln\left| x+a \right|]+c<br>$$</p><h4 id="第二类换元积分"><a href="#第二类换元积分" class="headerlink" title="第二类换元积分"></a>第二类换元积分</h4><p>概念：被积函数中含根式，且没有公式的不定积分</p><p>法一：</p><p>根式代换（根式为x的一次方）含一个一次根式<br>$$<br>\sqrt[n]{ax^1+b}<br>$$</p><p>或<br>$$<br>\sqrt[n]{\frac{ax^1+b}{cx^1+d}}<br>$$<br>例：<br>$$<br>\int \frac{dx}{1+\sqrt{x}}<br>$$</p><p><img src="https://uploader.shimo.im/f/Whz9YUmZJo7sw5qG.png!thumbnail" alt="img"><br>有理假分式处理成“整+真”分子 +1，-1法<br>多项式除法含两个一次根式<br>$$<br>\sqrt [m]{a+b}<br>$$<br>和<br>$$<br>\sqrt [n]{ax+b}<br>$$<br>令<br>$$<br>\sqrt[l]{ax+b}=t<br>$$<br>（l为m和n的最小公倍数）<br>例：<br>$$<br>\int \frac{dx}{(1+\sqrt[3]{x})\sqrt[2]{x}}<br>$$<br><img src="https://uploader.shimo.im/f/16YKGykpbvmjZnd7.png!thumbnail" alt="img"><br>令<br>$$<br>\sqrt[6]{x}=t,x=t^6<br>$$<br>法二：</p><p>三角代换 （根式为x的平方，平方和或平方差）<br>$$<br>\sqrt{x^2+a^2},\sqrt{x^2-a^2},\sqrt{a^2-x^2}. . .<br>$$<br><img src="https://uploader.shimo.im/f/fgLF3Z5k4G7qOZjS.png!thumbnail" alt="img"><br>推广↓<br><img src="https://uploader.shimo.im/f/uonNS9dQVU22AALW.png!thumbnail" alt="img"><br>例题还原<br><img src="https://uploader.shimo.im/f/qpDbbOScnPSaF7rA.png!thumbnail" alt="img"> </p><h3 id="理分式的不定积分"><a href="#理分式的不定积分" class="headerlink" title="理分式的不定积分"></a>理分式的不定积分</h3><p>有理分式：两个多项式的商<br>$$<br>\frac{P_n(x)}{Q_m(x)}<br>$$</p><ul><li><p>有理分式</p><ul><li><p>有理真分式  n&lt;m （分子幂次&lt; 分母幂次）</p></li><li><p>有理假分式  n≥m   (分子幂次&gt; 分母幂次)</p></li></ul></li><li><p>如何把有理假分式化为有理真分式 -&gt;多项式除法</p></li><li><p>例：</p></li></ul><p>$$<br>\frac {x^4-3x^2+3}{x-1}<br>$$</p><ol><li>第一步：把除式，被除式作降幂排列，并把所有缺的项用0补齐</li></ol><p>$$<br>\frac{x^4+0x^3-3x^2+0x^1+3}{x^1-1}<br>$$<br>2. 第二步：把分式分成模除式，用被除式的第一项除以除式的第一项，得商式的第一项</p><ol start="3"><li><p>第三步：用商式的第一项去乘除式，把积写在被除式下面（同类项【幂次相同】对齐），消去同类项，得差</p></li><li><p>第四步：用差和被除式结合为新的被除式，重复2-3步，直到余式的幂次低于除式的最高次</p></li></ol><p><img src="https://uploader.shimo.im/f/S7fwVFJtJTOjhQbE.png!thumbnail" alt="img"></p><h3 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h3><ul><li>公式</li></ul><p>$$<br>\int uv’dx=\int udv=uv-\int vdu<br>$$</p><ul><li><p>什么时候使用</p><ul><li>用于求两类不同函数乘积的积分或，被积函数只有一个函数的积分</li></ul></li><li><p>使用技巧</p><ul><li>两类不同函数按“反对幂三指”的顺序，哪个函数的顺序靠后，把哪个函数放在d后</li><li>注：放d后的函数要变为原函数 </li></ul></li></ul><h4 id="特例："><a href="#特例：" class="headerlink" title="特例："></a>特例：</h4><p>“三指”型会引发积分再现现象</p><p>解决：合并积分即可<br><img src="https://uploader.shimo.im/f/p1357dOT1ZXq9Igd.png!thumbnail" alt="img"> </p><h2 id="五章-定积分"><a href="#五章-定积分" class="headerlink" title="五章 定积分"></a>五章 定积分</h2><h3 id="第一节-定积分的概念和性质"><a href="#第一节-定积分的概念和性质" class="headerlink" title="第一节 定积分的概念和性质"></a>第一节 定积分的概念和性质</h3><p><font style="font-size:1.3rem;color:red">注：</font></p><ol><li><p>a=b时（上下限相等的定积分=0）<br>$$<br>\int_{a}^{b} f(x)dx=0<br>$$</p></li><li><p>a≠b时（<font style="color:red">交换</font>定积分<font style="color:red">上下限</font>，结果多一个<font style="color:red">负号</font>）</p></li></ol><p>$$<br>\int_{a}^{b} f(x)dx=-\int_{b}^{a} f(x)dx<br>$$</p><ol start="3"><li><p>b&gt;a时 （==保号性==）</p><ol><li>f(x)&gt;0   $\int_{a}^{b}f(x)dx&gt;0$</li><li>f(x)&lt;0  $\int_{a}^{b}f(x)dx&lt;0$</li></ol></li></ol><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><ul><li>b&gt;a<ul><li>f(x)≥0  <ul><li>$\int_{a}^{b} f(x)dx$  的值是曲边梯形的面积</li></ul></li><li>$f(x)≤0$<ul><li>$\int_{a}^{b} f(x)dx$  的值是曲边梯形面积的负值</li><li>被积函数和定积分都是小于零的 -&gt; 负负（面积）得正</li></ul></li><li>$f(x)$有正负<ul><li>$\int_{a}^{b} f(x)dx$  的值是各部分曲边梯形面积的<font style="color:red">代数和</font>，有正有负）</li></ul></li></ul></li></ul><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ol><li>若$f(x)$在[a,b]上连续$\Rightarrow f(x)$在[a,b]上可积，$\int_{a}^{b}f(x)dx$存在</li><li>若$f(x)$在[a,b]上有界，则仅有有限个第一类间断点$\Rightarrow f(x)$在[a,b]上可积（$\int_{a}^{b}f(x)dx$存在）</li></ol><blockquote><p> 注</p><ol><li>连续必可导，可导不一定连续</li><li>可导必连续，连续必可积，可积必有界</li></ol></blockquote><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>$\int_{a}^{b}[\alpha f(x)\pm\beta g(x)]dx=\alpha \int_{a}^{b}f(x)dx\pm\beta \int_{a}^{b}g(x)dx$ 和 数乘：$\int_{a}^{b} \alpha f(x)dx=\alpha\int_{a}^{b}f(x)dx$</li><li>区间可加性：$\int_{a}^{b}f(x)dx=\int_{a}^{c}f(x)dx+\int_{c}^{b}f(x)dx$ ，c是a-b之间的任意值</li><li>$\int_{a}^{b} 1dx=\int_{a}^{b}dx=b-a$ ，被积函数为1的定积分=区间长度b-a</li></ol><h3 id="第二节-微积分的基本公式"><a href="#第二节-微积分的基本公式" class="headerlink" title="第二节 微积分的基本公式"></a>第二节 微积分的基本公式</h3><h4 id="变限积分函数及其导数"><a href="#变限积分函数及其导数" class="headerlink" title="变限积分函数及其导数"></a>变限积分函数及其导数</h4><p><font style="color:hotpink">看到变限积分函数必求导</font></p><ul><li>变限积分函数计算基本公式<ul><li>变上限积分函数</li><li>变下限积分函数</li><li>变限积分函数</li><li>被积函数的变量与积分函数变量 相等</li></ul></li><li>定积分计算基本公式</li></ul><ol><li><p>若$f(x)$在[a,b]上连续，则</p><ol><li>$(\int_{a}^{x}f(t)dt)’=f(x)$ 把上限x代入被积函数f(t)中</li><li>$\int_{a}^{x}f(t)dt$是$f(x)$在[a,b]上的一个原函数（==小题常考==）</li></ol></li><li><p>若$f(x)$在[a,b]上连续，则</p><ol><li><p><span style="background:#ecf0f1;color:#95a5a6">$(\int_{a}^{x}f(t)dt)’=f(x)$,把上限x代入被积函数$f(x)$中</span></p></li><li><p><span style="background:#ecf0f1;color:#95a5a6">$(\int_{a}^{\varphi{(x)}}f(t)dt)’=f[\varphi(x)]·\varphi’(x)$，把上限$\varphi(x)$代入被积函数$f(t)$中，再乘上限$\varphi(x)$的导数</span></p></li><li><p><span style="background:#ecf0f1;color:#95a5a6">$(\int_{\varphi{(x)}}^{b}f(t)dt)’=-f[\varphi(x)]·\varphi’(x)$，把下限$\varphi(x)$代入被积函数$f(t)$中，再乘下限$\varphi(x)$的导数，别忘了加==负号==。</span></p></li><li><p>$(\int_{下}^{上}f(t)dt)’=f(上)·上’-f(x)·下’$,</p></li></ol></li></ol><h4 id="cow-牛顿莱布尼茨公式"><a href="#cow-牛顿莱布尼茨公式" class="headerlink" title=":cow:牛顿莱布尼茨公式"></a>:cow:牛顿莱布尼茨公式</h4><p>若$F(x)$是连续函数$f(x)$在[a,b]上的一个原函数</p><p>​    则：<img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E7%89%9B%E9%A1%BF%E8%8E%B1%E5%B8%83%E5%B0%BC%E8%8C%A8%E5%85%AC%E5%BC%8F.png" alt="牛顿莱布尼茨公式"></p><ol><li>先求不定积分</li><li>把上下限代入原函数：上限代入减去下限代入</li></ol><h3 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h3><h4 id="题型-3"><a href="#题型-3" class="headerlink" title="题型"></a>题型</h4><p><u>1. ==绝对值函数是特殊的分段函数==</u></p><p>如何把绝对值函数变成分段函数：</p><ul><li>方法：<ul><li>绝对值函数的零点就写成分段函数的分段点</li></ul></li><li>例题：<ul><li><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%8F%98%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0.png" alt="绝对值变分段函数"></li><li><font style="font-size:1.5rem;color:#e74c3c;">07年真题</font><ul><li>$\int_{0}^{\pi}\sqrt{2+2cosx}dx$,tips:①倍角公式②开<font style="color:red">偶次方根</font>要加<font style="color:red">绝对值</font>或正负号</li></ul></li><li><font style="font-size:1.5rem;color:#e74c3c;">09年真题</font><ul><li><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img09%E5%B9%B4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9C%9F%E9%A2%98.png" alt="09年定积分真题"></li><li>有两个间断点1和0，[-4,0],[0,1],[1,4] 三个区间</li></ul></li></ul></li></ul><p><u>2. 分段函数的定积分</u></p><ul><li>把分段函数的上下限（把分段函数的分段点插入定积分的上下限，然后利用定积分关于区间的可加性计算分段函数的定积分</li><li>例题<ul><li><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0%E5%AE%9A%E7%A7%AF%E5%88%8601.png" alt="分段函数定积分01"></li><li><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0%E5%AE%9A%E7%A7%AF%E5%88%86.png" alt="分段函数定积分"></li></ul></li></ul><h3 id="第三节-定积分换元法"><a href="#第三节-定积分换元法" class="headerlink" title="第三节 定积分换元法"></a>第三节 定积分换元法</h3><p>与不定积分大同小异</p><p><font style="font-size:1.5rem;color:orange">换元必换限</font></p><ul><li>法一<ul><li>把定积分去上下限，变成不定积分积，然后再代入限（只需换元，不许换限）</li></ul></li><li>法二<ul><li>既换元，又换限 ==（注意，在把x-&gt;t时，上下限要换成t的限）==</li><li><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E6%8D%A2%E5%85%83%E6%8D%A2%E9%99%90.png" alt="换元换限"></li></ul></li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>①三角代换(平方和、平方差的形式)</p><p>②定积分的几何意义</p><p>③$t^2+1-1$</p><p>④$y^2+x^2=1$,圆公式</p><p>⑤注意复合函数求导用链式法则，$(uv)’$</p><p>⑥假分式-&gt;真分式+整式（多项式除法）</p><p>⑦真分式 -&gt; 把$\sqrt{x}$换成t</p><ol><li>$\int_{0}^{3} \frac{\sqrt{x}}{1+x}dx$<ol><li>$2(\sqrt{3}-\frac{\pi}{3})$</li></ol></li><li>$\int_{0}^{4} \frac{x+2}{\sqrt{2x+1}}dx$<ol><li>$\frac{22}{3}$</li></ol></li><li>$\int_{1}^{4} \frac{e^\sqrt{x}}{\sqrt{x}}dx$<ol><li>2[$e^2-e$]</li></ol></li><li>$\int_{0}^{a} \sqrt{a^2+x^2}dx$,(a&gt;0)<ol><li>$\frac{\pi a^2}{4}$</li></ol></li><li>$\int_{0}^{2}(x+\sqrt{2x-x^2})dx$<ol><li>2+$\frac {\pi}{2}$</li><li>$(x-1)^2+y^2)=1$,圆心（1，0），半径为1.</li></ol></li><li>$\int_{0}^{2} \sqrt{2x-x^2}dx$<ol><li>$\frac{\pi}{2}$</li></ol></li></ol><h3 id="第五节-奇零偶倍-不难，很重要"><a href="#第五节-奇零偶倍-不难，很重要" class="headerlink" title="第五节 奇零偶倍 不难，很重要"></a>第五节 奇零偶倍 <font style="color:hotpink;font-size:1.5rem;text-shadow:3px 3px 30px #fd79a8">不难，很重要</font></h3><ul><li>特点<ul><li>积分区间对称<ul><li>$\int_{-\pi}^{\pi}$</li></ul></li><li>被积函数<ul><li>奇函数   <span style="background:#2ecc71">0</span> <img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img0ABC59F1.png" alt="img"></li><li>偶函数  $2\int_{0}^{a}f(x)dx$,<span style="background:#2ecc71">2倍的积分区间的一半</span></li></ul></li></ul></li><li>奇偶函数<ul><li>sinx是特殊的奇函数</li><li>常函数是偶函数</li></ul></li><li>公式<ul><li>偶*奇=奇</li><li>偶+偶=偶</li><li>偶/偶=偶</li><li>奇/偶=奇</li><li>偶+奇=非奇非偶</li><li>非奇非偶/奇（偶）=非奇非偶</li></ul></li></ul><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%8F%98%E9%99%90%E7%A7%AF%E5%88%8613%E7%9C%9F%E9%A2%98.png" alt="变限积分13真题"></p><h2 id="六章-定积分的应用"><a href="#六章-定积分的应用" class="headerlink" title="六章 定积分的应用"></a>六章 定积分的应用</h2><ul><li>应用</li></ul><ol><li>平面图形的面积</li><li>旋转体体积</li></ol><ul><li>==平面图形的面积==可以分为<ul><li>x型</li><li>y型</li><li>混合型</li></ul></li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/imgx%E5%9E%8B%E5%92%8Cy%E5%9E%8B.png" alt="x型和y型"></p><ol><li>x型</li></ol><ul><li>曲线y=y(x)沿x轴方向围成的平面图形<ul><li><u>特点（判断依据）</u><ul><li>在图形内，作一条垂直于x轴的射线，需满足<ul><li>只能有2条交线</li><li>随着射线的平移，两交线不能发生变化</li><li><em>注：若随着射线的平移，交线发生了变化，则可在发生变化的点，把图形分成两个x型区域</em></li></ul></li></ul></li><li><u>把x型平面图形写成不等式：</u><ul><li>写出x的范围（常数）和y的范围（函数） </li></ul></li><li><u>把图形D（不等式组）写成定积分</u><ul><li>x对应上下限</li><li>y对应函数式</li></ul></li></ul></li></ul><ol start="2"><li>y型</li></ol><ul><li>曲线$x=\varphi{(y)}$,沿y轴形成的图形<ul><li><u>特点（判断依据）</u><ul><li>在图形内，作一条垂直于x轴的射线，需满足<ul><li>只能有2条交线</li><li>随着射线的平移，两交线不能发生变化</li><li><em>注：若随着射线的平移，交线发生了变化，则可在发生变化的点，把图形分成两个y型区域</em></li></ul></li></ul></li><li><u>把x型平面图形写成不等式：</u><ul><li>写出y的范围（常数）和x的范围（函数） </li></ul></li><li><u>把图形D写成定积分</u><ul><li>y对应上下限</li><li>x对应函数式</li></ul></li></ul></li></ul><ol start="3"><li>混合型<ul><li>x+x，y+y,x+y </li></ul></li></ol><h4 id="⭐总结"><a href="#⭐总结" class="headerlink" title="⭐总结"></a>⭐总结</h4><p>利用定积分的几何意义求平面图形的面积</p><ol><li>确定图形的类型（x型、y型）<ol><li>在图形内作垂线（想判断哪种类型，就向哪个轴作==垂线==↓）<ol><li>只有两条交线</li><li>随着垂线平移，交线不变</li></ol></li></ol></li><li>把图形写成不等式组（图形为哪个类型，哪个变量范围为常数，另一变量范围为函数）</li><li>把不等式组写成定积分，即图形的面积<ol><li>常数的范围写成定积分的限</li><li>函数范围写成定积分的被积函数（大交线-小交线）<ol><li>注：选用的图形类型（x,y）与写成定积分中的积分变量（dx\dy）和积分限（上下限）保持一致</li></ol></li></ol></li></ol><ul><li>==旋转体体积==</li><li>平面图形D绕坐标轴旋转所形成旋转体的体积<ul><li>x型D绕x轴形成的旋转体体积$V_D=V_{xD},x$</li><li>x型D绕x轴形成的旋转体体积$V_D=V_{yD},y$，型和轴一致（y型，y轴）</li><li>异型旋转不考<img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img0B60FBD0.png" alt="img"></li><li>x型D绕y轴形成的旋转体体积$V_D=V_{xD},y$</li><li>y型D绕x轴形成的旋转体体积$V_D=V_{yD},x$</li></ul></li><li><strong>tips：面积，旋转体体积，二重积分。都是这三步走。</strong></li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/imgx%E5%9E%8BD%E7%9A%84%E6%97%8B%E8%BD%AC%E4%BD%93%E4%BD%93%E7%A7%AF.png" alt="x型D的旋转体体积"></p><p>旋转体体积</p><ul><li><p>法一：圆片法</p><ul><li>同型转，多π多平方</li></ul></li><li><p>法二：柱壳法</p><ul><li>异型转，多乘2π多乘自变量</li></ul></li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E6%9F%B1%E5%A3%B3%E6%B3%95.png" alt="柱壳法"></p><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%A4%9A%E4%B9%982%CF%80%E5%A4%9A%E4%B9%98%E8%87%AA%E5%8F%98%E9%87%8F.png" alt="多乘2π多乘自变量"></p><h2 id="第七章-微分方程"><a href="#第七章-微分方程" class="headerlink" title="第七章 微分方程"></a>第七章 微分方程</h2><h3 id="第一节-基本概念"><a href="#第一节-基本概念" class="headerlink" title="第一节 基本概念"></a>第一节 基本概念</h3><ul><li><p><u>微分方程</u></p></li><li><p>定义：含有<span style="background:#ddd">自变量（x），未知函数(y(x))</span>及其<span style="background:#99c">导数(y’,y’’)（或微分dy）</span>的等式，称为微分方程,<font style="color:red;weight:1000">其中,未知函数的导数或微分<strong>必须有</strong>，而自变量和未知函数<strong>可有可无</strong></font></p></li><li><p>常微分方程：未知函数是==一元函数==的微分方程，称为常微分方程。</p><ul><li>标志：最多两个字母，一个自变量，一个函数</li></ul></li><li><p><u>阶</u></p></li><li><p>定义：方程中未知函数导数的最高阶阶数为方程的阶</p></li><li><p><u>线性微分方程</u></p></li><li><p>y’’和d’’y自身之间或彼此之间只能进行线性运算</p><ul><li><p>a和b之间的运算：加减、乘除、数乘（2a ，一个数乘一个变量）、复合（cosa,lna,lnb)</p><ul><li>加减和数乘是线性（直线）运算，乘除和复合是非线（曲线）性运算</li></ul></li><li><p>判断哪个是线性微分方程</p><ul><li>y’*cosx。线性，因为是对x进行复合运算</li><li>y·y’’。非线性，y相当于y的零阶导</li><li>x·y’’。线性</li></ul></li></ul></li><li><p>代数方程</p><ul><li>含有未知数的等式，其解为特定的数。</li></ul></li><li><p>函数方程</p><ul><li>含有未知函数的等式，其解为函数</li><li>注：==微分方程是特殊的函数方程==，特殊在含有未知函数的导数。故微分方程的解也是函数</li></ul></li><li><p>解</p><ul><li>定义：若函数$y=\varphi(x)$代入微分方程中，能使方程成立，则函数$y=\varphi(x)$为方程的解。</li><li>解的特征：把解代入方程中，使方程成立</li><li>分类<ul><li>通解：含有<span style="background:#f1c40f">相互独立</span>（不能合并）的任意常数（$c_1,c_2$），且任意常数的<span style="background:#e67e22">个数</span>与方程<span style="background:#e67e22">阶数</span><strong>相同</strong></li><li>特解：不含任意常数的解</li></ul></li></ul></li></ul><hr><p>一阶微分方程的分类</p><ol><li>一阶可分离变量的微分方程</li><li>一阶线性微分方程</li><li>一阶齐次微分方程</li></ol><ul><li><input checked="" disabled="" type="checkbox"> 如何分类 （重难点）</li><li><input disabled="" type="checkbox"> 如何求解</li></ul><hr><h3 id="第二节-可分离变量的微分方程"><a href="#第二节-可分离变量的微分方程" class="headerlink" title="第二节 可分离变量的微分方程"></a>第二节 可分离变量的微分方程</h3><ul><li><p><u>标准方程：</u>$f(x)dx=f(y)dy$     (理想状态)</p></li><li><p>题目中：$y’=f(x)g(y)$或$y’=\frac{f(x)}{g(y)}$,   ⭐==（可化为<span style="border:3px solid lightblue;height:40px;width:100px">y’在左边</span>，右边是<span style="border:3px solid lightblue;height:40px;width:100px">纯x函数与纯y函数</span><strong>相乘、除</strong>的形式）==就是可分离变量的微分方程</p><ul><li>例：$y’=sinx·cosy$，$y’=\frac{x^2}{y}$</li></ul></li><li><p>题目中的-&gt;标准方程</p></li></ul><p>第一种情况</p><ol><li><p>$y’=f(x)g(y)$</p></li><li><p>$\frac{dy}{dx}=f(x)g(y)$</p></li><li><p>$dy=f(x)g(y)dx$</p></li><li><p>$\frac{dy}{g(y)}=f(x)dx$</p></li></ol><p>第二种情况</p><ol><li>$y’\frac{f(x)}{g(y)}$</li><li>$\frac{dy}{dx}=\frac{f(x)}{g(y)}$</li><li>$g(y)dy=f(x)dx$</li></ol><ul><li><u>解法：</u><ul><li>①先把方程化为现实状态：$y’=f(x)g(y)$或$y’=\frac{f(x)}{g(y)}$(y’在左边，右边是纯x函数与纯y函数相乘除)</li><li>②再把现实状态化为理想状态：$f(y)dy=f(x)dx$,纯y函数dy=纯x函数dx）-&gt; 分离变量</li><li>③对理想状态两边同时积分：$f(y)dyx=f(x)dx$</li></ul></li><li>例题：</li></ul><h2 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章 向量代数与空间解析几何"></a>第八章 向量代数与空间解析几何</h2><h3 id="一、空间直角坐标系"><a href="#一、空间直角坐标系" class="headerlink" title="一、空间直角坐标系"></a>一、空间直角坐标系</h3><ul><li>(x,y,z)的对称点<ul><li>关于原点对称：(-x,-y,-z)</li><li>关于坐标轴对称:<span style="background:hotpink;color:white;padding:5px">(x,y,z)关于哪个字母对称，哪个字不变其余字母变负</span> <ul><li>x轴:(x,-y,-z)</li><li>y轴:(-x,y,-z)</li><li>z轴:(-x,-y,z)</li></ul></li><li>关于坐标平面对称（xoy平面）<ul><li>xoy(x,y,-z)</li><li>yoz-x,y,z)</li><li>xoz(x,-y,z)</li></ul></li></ul></li></ul><p><span style="border:3px solid lightblue">两点间距离公式：</span> $(x,y),(x_1,y_1)$-&gt;$\sqrt{(x_1-x)^2+(y_1-y)^2}$</p><h3 id="二、向量"><a href="#二、向量" class="headerlink" title="二、向量"></a>二、向量</h3><ol><li>概念：<ul><li>定义：既有大小又有方向的量</li><li>表示<ul><li>坐标表示<ul><li> $\vec a=(\overbrace {a_x,a_y,a_z}^{向量的分量})$</li><li>$A(x_1,y_1,z_1)、B(x_2,y_2,z_2)$  <font style="color:red;font-size:1.5rem">↓↓</font> </li><li>$\overrightarrow{AB}=(x_2-x_1,y_2-y_1,z_2-z_1)$,（终点减起点坐标）</li></ul></li><li>向量表示<ul><li>$\vec a=a_x \cdot \vec i+a_y\cdot\vec j+a_z\cdot\vec k$ =&gt; <font style="color:hotpink;font-size:1.5rem">i,j,l代表沿坐标轴方向的单位向量</font> </li></ul></li></ul></li><li>向量的模：向量的长度（大小）<ul><li>$|\vec a|=\sqrt{a_x^2+a_y^2+a_z^2}$.</li></ul></li><li>单位向量<ul><li>模长为1的向量</li><li>单位化（小题）</li><li>$$\frac{\vec{a}}{|\vec{a}|}$$,向量/模长</li></ul></li></ul></li></ol><h3 id="三、方向余弦"><a href="#三、方向余弦" class="headerlink" title="三、方向余弦"></a>三、方向余弦</h3><ol><li>方向角</li></ol><p>概念：向量$$\vec{a}$$与坐标轴方向的夹角。</p><p>$$\alpha,\beta,\gamma$$,$$\vec{a}$$与x,y,z轴方向的夹角。</p><p>==注==：</p><p>①范围$$\in[1,\pi]$$;</p><p>②$$\cos^2\alpha+\cos^2\beta+cos^2\gamma=1$$;</p><ol start="2"><li>方向余弦</li></ol><p>向量$$\vec{a}=(a_x,a_y,a_z)$$方向余弦<br>$$<br>\cos \alpha=\frac{a_x}{\vert\vec{a}\vert}<br>$$</p><h3 id="四、向量的线性运算"><a href="#四、向量的线性运算" class="headerlink" title="四、向量的线性运算"></a>四、向量的线性运算</h3><ul><li>向量的线性运算</li></ul><p>1). $$\vec a \pm \vec b=(a_x+b_x,a_y+b_y,a_z+b_z)$$对应坐标相加减。</p><p>2). 数乘：$$\lambda \vec a=(\lambda a_x,\lambda a_y,\lambda a_z)$$.数乘向量=用数分别乘向量的分量（数乘向量就是对向量伸缩若干倍）</p><p>==注：==数乘后的向量与数乘前的向量是平行或共线的。<font style="color:red;font-size:1.5rem">平行，对应分量成比例</font> 。</p><ul><li><p>向量的数量积</p><ul><li><p>数量积（点乘）</p></li><li><p>定义式（理论，不用于计算）</p><ul><li><p>$$<br>\vec a \cdot \vec b = |\vec a| \cdot|\vec b| \cos(\vec a \land \vec b)<br>$$</p><ul><li>主要是用来计算向量之间的==夹角==</li></ul></li><li><p>$$<br>\cos (\vec a \land \vec b)=\frac{\vec a \cdot \vec b}{|\vec a||\vec b|},\cos(\vec a \land \vec b) \in[0,\pi]<br>$$</p></li></ul></li></ul></li><li><p>计算式</p><ul><li><p>$$<br>\vec a \cdot \vec b=a_xb_x+a_yb_y+a_zb_z<br>$$</p></li><li><p>a,b对应坐标先相乘再相加。</p></li><li><p>性质</p><ul><li>① $$\vec a \cdot \vec a=|\vec a| \cdot|\vec a| \cdot \cos \theta=|\vec a|^2$$；</li><li>② $$\vec a \cdot \vec b=\vec b \cdot \vec a$$；</li></ul></li><li><p>充要条件==*==</p><ul><li>$$\vec a \bot \vec b \Leftrightarrow \vec a\cdot \vec b=0$$.</li><li>$$\vec a // \vec b\Leftrightarrow\frac{a_x}{b_x}=\frac{a_y}{b_y}=\frac{a_z}{b_z}=\lambda$$.</li></ul></li></ul></li><li><p>⭐⭐向量的向量积（叉乘）</p><ul><li><blockquote><p>向量的点乘是C（常数）</p></blockquote></li><li><blockquote><p>向量的叉乘还是向量</p></blockquote></li><li><p>方向</p><ul><li>$$\vec a ×\vec b =\vec c$$.</li><li>$$\vec c \bot \vec a,\vec c \bot \vec b$$.</li></ul></li><li><p>大小（模长）</p><ul><li>$$|\vec c|=|\vec a × \vec b|=|\vec a||\vec b|sin(\vec a\land \vec b)$$.（定义式）</li><li>$$|\vec c|=|\vec a × \vec b|$$，几何意义。以$$\vec a，\vec b$$为邻边构成平行四边形的面积</li></ul></li><li><p>计算式：==三阶行列式==，去掉当前所在行，所在列。交叉相乘。i-j+k;</p></li><li><p>性质：</p><ul><li>$$\vec a × \vec a =\vec 0$$.（零向量）</li><li>$$\vec a × \vec b =-\vec b × \vec a$$.==（无交换率）==</li></ul></li><li><p>充要条件</p><ul><li>$$\vec a \Vert\vec b \Leftrightarrow \vec a×\vec b=\vec 0 \Leftrightarrow \vec a= \lambda \vec b$$.</li><li>$$\frac{a_x}{b_x}=\frac{a_y}{b_y}=\frac{a_z}{b_z}$$. ⭐⭐</li></ul></li></ul></li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%8F%89%E4%B9%98%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" alt="叉乘的几何意义"></p><blockquote><p>注：怎么找一个既垂直于$$\vec a$$，又垂直于$$\vec b$$的向量。  </p><p>方法：做叉乘。</p></blockquote><h3 id="五、平面方程"><a href="#五、平面方程" class="headerlink" title="五、平面方程"></a>五、平面方程</h3><h4 id="（1）点法式方程"><a href="#（1）点法式方程" class="headerlink" title="（1）点法式方程"></a>（1）点法式方程</h4><ul><li>公式推导</li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E7%82%B9%E6%B3%95%E5%BC%8F%E6%96%B9%E7%A8%8B.png" alt="点法式方程"></p><p>A,B,C 是法向量。x-x0,y-y0,z-z0。是平面上的点。</p><p>$$<br>A(x-x_0)+B(y-y_0)+C(z-z_0)=0<br>$$</p><h4 id="（2）一般式方程"><a href="#（2）一般式方程" class="headerlink" title="（2）一般式方程"></a>（2）一般式方程</h4><ul><li>公式推导</li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E4%B8%80%E8%88%AC%E5%BC%8F%E6%96%B9%E7%A8%8B%E6%8E%A8%E5%AF%BC.png" alt="一般式方程推导"></p><h4 id="特殊的一般式平面方程"><a href="#特殊的一般式平面方程" class="headerlink" title="特殊的一般式平面方程"></a>特殊的一般式平面方程</h4><p>==D是$$\pi$$到坐标轴的距离==</p><p>①</p><p>D=0 $$\Leftrightarrow \pi$$<strong>过</strong>原点</p><p>②</p><p>C=0$$\Leftrightarrow \pi$$//z轴</p><p>B=0$$\Leftrightarrow\pi$$//y轴</p><p>A=0$$\Leftrightarrow\pi$$//x轴</p><blockquote><p>方程中谁的系数=0，平面就平行于谁</p></blockquote><p>③</p><p>C=0，D=0$$\Leftrightarrow\pi$$过z轴</p><p>B=0，D=0$$\Leftrightarrow\pi$$过y轴</p><p>A=0，D=0$$\Leftrightarrow\pi$$过x轴</p><blockquote><p>平面在平行轴的基础上加”D=0”</p><p>=&gt;平面过这个轴</p></blockquote><p>④</p><p>B=C=0$$\Leftrightarrow\pi$$//yoz平面</p><p>A=C=0$$\Leftrightarrow\pi$$//xoz平面</p><p>方程中谁的系数=0，=&gt; 平面//谁。</p><h4 id="待定系数法"><a href="#待定系数法" class="headerlink" title="待定系数法"></a>待定系数法</h4><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E4%B8%80%E8%88%AC%E6%98%AF%E6%96%B9%E7%A8%8B%E5%BE%85%E5%AE%9A%E7%B3%BB%E6%95%B0%E6%B3%95.png" alt="一般是方程待定系数法"></p><h4 id="向量之间位置关系"><a href="#向量之间位置关系" class="headerlink" title="向量之间位置关系"></a>向量之间位置关系</h4><p>判断思路。（3种方法）</p><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%90%91%E9%87%8F%E4%B9%8B%E9%97%B4%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB.png" alt="向量之间位置关系"></p><p>平行关系的例题：</p><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%90%91%E9%87%8F%E5%B9%B3%E8%A1%8C%E4%BE%8B%E9%A2%9801.png" alt="向量平行例题01"></p><h3 id="六、直线方程"><a href="#六、直线方程" class="headerlink" title="六、直线方程"></a>六、直线方程</h3><h4 id="直线于直线的位置关系-（与向量位置关系相同）"><a href="#直线于直线的位置关系-（与向量位置关系相同）" class="headerlink" title="直线于直线的位置关系 （与向量位置关系相同）"></a>直线于直线的位置关系 （与向量位置关系相同）</h4><ul><li>平行</li><li>垂直</li><li>重合<ul><li>平行</li><li>有交点(带入点，等于交点处坐标？)</li></ul></li></ul><h4 id="⭐直线与平面的位置关系（与向量位置关系相反）"><a href="#⭐直线与平面的位置关系（与向量位置关系相反）" class="headerlink" title="⭐直线与平面的位置关系（与向量位置关系相反）"></a>⭐直线与平面的位置关系（与向量位置关系相反）</h4><p>线面平行-&gt;法向量与方向向量垂直</p><p>垂直-&gt;平行</p><p>重合-&gt;1）平行，2）直线上的点$$(x_0,y_0,z_0)$$在平面上。</p><h4 id="专升本狗-外"><a href="#专升本狗-外" class="headerlink" title="专升本狗 外"></a>专升本狗 外</h4><ul><li>点到平面距离公式</li></ul><p>点到平面的距离公式：设点P$$(x_0,y_0,z_0)$$到平面$$\pi：Ax+By+Cz+D=0$$的距离d<br>$$<br>d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}<br>$$</p><ul><li><p>空间直线方程</p><ul><li>直线的<strong>点向式</strong>方程：$$\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}$$.<ul><li>称平行于直线的向量为方向向量，$$\vec s=(m,n,p)$$.</li><li>取直线上两不重合的点M(x,y,z),$$M_0(x_0,y_0,z_0)$$,连接$$M_0M$$得：</li><li>$$\vec {M_0M}=(x-x_0,y-y_0,z-z_0)$$有$$\vec {M_0M}//\vec s$$.</li><li>平行，对应坐标成比例。</li></ul></li></ul></li><li><p>参数方程</p><ul><li><p>$$<br>\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}=t \Rightarrow \frac{x-x_0}{m}=t,x=x_0+mt<br>$$</p></li><li><p>一般用于求交点。</p></li></ul></li><li><p>直线得一般式（交面式）</p><ul><li>由两平面相交而成得直线</li><li>$$A_1x+B_1y+C_1z+D_1=0$$.</li><li>$$A_2x+B_2y+C_2z+D_2=0$$.</li></ul></li></ul><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E4%BA%A4%E9%9D%A2%E5%BC%8F%E6%96%B9%E7%A8%8B.png" alt="交面式方程"></p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>直线与直线之间的关系</p><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E7%9B%B4%E7%BA%BF%E4%B8%8E%E7%9B%B4%E7%BA%BFeg01.png" alt="直线与直线eg01"></p><p>L2的x0，y0,z0代入L1中 是否满足L1的方程。</p><p>如果满足，重合。否则平行。</p><h2 id="附录：高中知识"><a href="#附录：高中知识" class="headerlink" title="附录：高中知识"></a>附录：高中知识</h2><h3 id="一、分解因式："><a href="#一、分解因式：" class="headerlink" title="一、分解因式："></a>一、分解因式：</h3><p>（一）定义： </p><blockquote><p>将一个多项式（有很多项 相加减每一项都是幂函数）分解成几个式子相乘的形式 </p></blockquote><p>（二）方法 </p><ul><li>提公因式法 <ul><li>公式法</li><li>平方差<ul><li>$$<br>a^2-b^2=(a+b)*(a-b)<br>$$</li></ul></li><li>立方差<ul><li>$$<br>a^3-b^3=(a-b)*(a^2+ab+b^2)<br>$$</li></ul></li><li>立方和</li></ul></li></ul><p>$$<br>a^3+b^3=(a+b)*(a^2-ab+b^2)<br>$$</p><p><strong>立方和差总结：</strong></p><p><font style="color:rgb(52,152,219);font-size:1.5rem">同号，异号，不变号</font><br>$$<br>a^3±b^3=(a±b)*(a^2（-+）ab+b^2）<br>$$</p><ul><li>完全平放式</li></ul><p>$$<br>(a+b)^2=a^2+2ab+b^2<br>$$</p><p>⭐ <span style="background:rgb(231,76,60);color:white;padding:5px">十字相乘法</span> ：适用于一元二次多项式 </p><ul><li>分解方法<ul><li>两边分解  </li><li>交叉相乘  </li><li>相加配中</li></ul></li></ul><h3 id="二、解不等式"><a href="#二、解不等式" class="headerlink" title="二、解不等式"></a>二、解不等式</h3><h4 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h4><ol><li>不等式两边同时加减任意数，不等号不变号  </li><li>不等式两边同时乘除任意数，不等号不变号  </li><li>不等式两边同时乘除一个<font style="color:red;font-size:1.5rem">负</font> 数，不等号变号 </li></ol><h4 id="二次不等式"><a href="#二次不等式" class="headerlink" title="二次不等式"></a>二次不等式</h4><ol><li>二次方程的求解</li></ol><p>$$<br>ax^2+bx+c=0<br>$$</p><h5 id="根的情况：（-delta-b-2-4ac-）"><a href="#根的情况：（-delta-b-2-4ac-）" class="headerlink" title="根的情况：（$$\delta=b^2-4ac$$.）"></a>根的情况：（$$\delta=b^2-4ac$$.）</h5><ul><li>$$\delta$$&gt;0 两个不同的实根</li><li>$$\delta$$=0 两个相同的实根</li><li>$$\delta$$&lt;0 无实根，有一对共扼复根</li></ul><h5 id="求根的方法："><a href="#求根的方法：" class="headerlink" title="求根的方法："></a>求根的方法：</h5><ol><li>十字相乘</li><li>配方法</li><li>求根公式：$$-b\pm \frac{\sqrt{b^2-4ac}}{2a}$$.</li></ol><h4 id="二次不等式的求解"><a href="#二次不等式的求解" class="headerlink" title="二次不等式的求解"></a>二次不等式的求解</h4><h5 id="求解方法："><a href="#求解方法：" class="headerlink" title="求解方法："></a>求解方法：</h5><ol><li> 把二次项系数化为正</li><li> 取等求根</li><li>口诀：<font style="color:red;font-size:1.5rem">大于</font> 取两边，<font style="color:red;font-size:1.5rem">小于</font> 取中间（二次项系数化为正的不等号）</li></ol><h5 id="绝对值不等式的解法"><a href="#绝对值不等式的解法" class="headerlink" title="绝对值不等式的解法"></a>绝对值不等式的解法</h5><p>口诀：大于取两边，小于取中间不等号 </p><h2 id="后续章节做题思路"><a href="#后续章节做题思路" class="headerlink" title="后续章节做题思路"></a>后续章节做题思路</h2><h3 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h3><p>二重积分的性质</p><p>二重积分可积与可导、连续、可微之间的关系。</p><h4 id="交换积分次序"><a href="#交换积分次序" class="headerlink" title="交换积分次序"></a>交换积分次序</h4><ol><li>⭐画图</li><li>定限（定义域）</li></ol><ul><li>后积先定限</li><li>限内正向穿</li><li>先交写下限，后交写上限</li></ul><p>特殊的 $$\int_{\frac{1}{2}}^{1}dy\int_{\frac{1}{y}}^{2}f(x,y)dx+\int_{1}^{2}dy\int_{y}^{2}f(x,y)dx$$.</p><ul><li>图画一块</li><li>区域D</li><li>解就完事了</li></ul><h4 id="求图形区域面积"><a href="#求图形区域面积" class="headerlink" title="求图形区域面积"></a>求图形区域面积</h4><p>补充（圆的方程式）：</p><ul><li>$$x^2+y^2=r^2$$圆的面积公式。原点（0，0），半径为r</li><li>$$(x-a)^2+(y-b)^2=r^2$$.其中a,b是圆心坐标，r为半径。</li></ul><ol><li>定型</li><li>求区域D</li><li>解二重积分（后写的先积）</li></ol><h4 id="一定条件下比较二重积分大小"><a href="#一定条件下比较二重积分大小" class="headerlink" title="一定条件下比较二重积分大小"></a>一定条件下比较二重积分大小</h4><p>随缘解</p><h3 id="全微分-amp-求偏导"><a href="#全微分-amp-求偏导" class="headerlink" title="全微分&amp;求偏导"></a>全微分&amp;求偏导</h3><ul><li>定义域。二元不等式即可</li><li>多元函数的dz是求全微分。</li><li>驻点即求一阶导</li><li>可微必连续，连续不一定可微（充分不必要条件）</li><li>可微则偏导存在，偏导存在不一定可微（充分不必要条件）</li></ul><p><strong>求偏导：</strong></p><p>$$\frac{\partial{f}}{\partial{x}}、\frac{\partial^2f}{\partial x^2}$$ ,一阶偏导、二阶偏导。</p><p>全微分：</p><p>$$dz=\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial y}dy$$,解完，合并同类项简化。</p><p><strong>复合函数偏导：</strong></p><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0x%EF%BC%8Cy.png" alt="复合函数x，y"></p><p>公式：$$\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u} \cdot \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v}\cdot\frac{\partial v}{\partial x}$$,y同理。</p><p><strong>复合函数求导数：</strong></p><p>推导出各多元函数之间的关系。</p><p><img src="https://typora-pic-1305180133.cos.ap-beijing.myqcloud.com//typora/img%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E4%B8%80%E9%98%B6%E5%AF%BCt.png" alt="复合函数一阶导t"></p><p>公式：$$\frac{dz}{dt}=\frac{\partial z}{\partial x} \cdot \frac{dx}{dt}+\frac{\partial z}{\partial y} \cdot \frac{dy}{dt}$$.</p><p><strong>特殊的复合函数的一阶偏导数</strong>：</p><p>例：<br>$$<br>z=f(x^2-y^2,e^{xy})<br>$$</p><ol><li>将$$x^2-y^2$$看作“1”；$$e^{xy}$$看作“2”.</li><li>对x求偏导：对f “1”的x求偏导，加上，对f “2”的x求偏导。（y同理）</li></ol><p>结果为：$$\frac{\partial z}{\partial x}=2xf’_1+ye^{xy}f’_2$$.</p><h3 id="多元函数求极值"><a href="#多元函数求极值" class="headerlink" title="多元函数求极值"></a>多元函数求极值</h3><ol><li>一阶导求驻点。</li><li>A=fxx，B=fxy，C=fyy</li><li>$$B^2-AC&lt;0$$有极值。反之无极值。</li><li>有极值并   A&gt;0 有极小值；反之有极大值。</li><li>将驻点值代入原式求极大极小值即可</li></ol><h3 id="空间向量与解析几何"><a href="#空间向量与解析几何" class="headerlink" title="空间向量与解析几何"></a>空间向量与解析几何</h3><hr><p>==开偶次方根，一定记得加正负号。==</p><p>见机行事</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://uploader.shimo.im/f/KA4ZlZ8XHcy633sA.png!thumbnail&quot; align=&quot;center&quot;&gt;

&lt;h2 id=&quot;一章-函数与极限&quot;&gt;&lt;a href=&quot;#一章-函数与极限&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="zsb" scheme="http://example.com/tags/zsb/"/>
    
  </entry>
  
</feed>
